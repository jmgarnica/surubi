//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g 2017-04-01 01:37:22

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


	using System;
	using TigerCs.Generation.AST.Expressions;
	using TigerCs.Generation.AST.Declarations;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

namespace TigerCs.Parser.Tiger
{
	[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
	[System.CLSCompliant(false)]
	public partial class TigrammarParser : Antlr.Runtime.Parser
	{
		internal static readonly string[] tokenNames = new string[] {
			"<invalid>", "<EOR>", "<DOWN>", "<UP>", "AND", "ARRAY", "ASSIGN", "BREAK", "COLON", "COMMA", "COMMENT", "CONTROL_CHARS", "DECIMAL_ESC", "DIGIT", "DIV", "DO", "DOT", "DQUOTE", "ELSE", "END", "EQUAL", "ESC_SEQ", "FOR", "FUNCTION", "GTHAN", "GTHAN_EQUAL", "ID", "IF", "IN", "INT", "LET", "LETTER", "LTHAN", "LTHAN_EQUAL", "L_BRACKETS", "L_KEY", "L_PARENT", "MINUS", "MULT", "NIL", "NOT_EQUAL", "OF", "OR", "PLUS", "R_BRACKETS", "R_KEY", "R_PARENT", "SEMICOLON", "STRING", "THEN", "TO", "TYPE", "VAR", "WHILE", "WS"
		};
		public const int EOF=-1;
		public const int AND=4;
		public const int ARRAY=5;
		public const int ASSIGN=6;
		public const int BREAK=7;
		public const int COLON=8;
		public const int COMMA=9;
		public const int COMMENT=10;
		public const int CONTROL_CHARS=11;
		public const int DECIMAL_ESC=12;
		public const int DIGIT=13;
		public const int DIV=14;
		public const int DO=15;
		public const int DOT=16;
		public const int DQUOTE=17;
		public const int ELSE=18;
		public const int END=19;
		public const int EQUAL=20;
		public const int ESC_SEQ=21;
		public const int FOR=22;
		public const int FUNCTION=23;
		public const int GTHAN=24;
		public const int GTHAN_EQUAL=25;
		public const int ID=26;
		public const int IF=27;
		public const int IN=28;
		public const int INT=29;
		public const int LET=30;
		public const int LETTER=31;
		public const int LTHAN=32;
		public const int LTHAN_EQUAL=33;
		public const int L_BRACKETS=34;
		public const int L_KEY=35;
		public const int L_PARENT=36;
		public const int MINUS=37;
		public const int MULT=38;
		public const int NIL=39;
		public const int NOT_EQUAL=40;
		public const int OF=41;
		public const int OR=42;
		public const int PLUS=43;
		public const int R_BRACKETS=44;
		public const int R_KEY=45;
		public const int R_PARENT=46;
		public const int SEMICOLON=47;
		public const int STRING=48;
		public const int THEN=49;
		public const int TO=50;
		public const int TYPE=51;
		public const int VAR=52;
		public const int WHILE=53;
		public const int WS=54;

		public TigrammarParser(ITokenStream input)
			: this(input, new RecognizerSharedState())
		{
		}
		public TigrammarParser(ITokenStream input, RecognizerSharedState state)
			: base(input, state)
		{
			OnCreated();
		}

		public override string[] TokenNames { get { return TigrammarParser.tokenNames; } }
		public override string GrammarFileName { get { return "E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g"; } }


		enum DclType {None, Type, Var, Function}


		partial void OnCreated();
		partial void EnterRule(string ruleName, int ruleIndex);
		partial void LeaveRule(string ruleName, int ruleIndex);

		#region Rules
		partial void EnterRule_program();
		partial void LeaveRule_program();

		// $ANTLR start "program"
		// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:125:8: public program returns [IExpression r] : e= expression EOF ;
		[GrammarRule("program")]
		public IExpression program()
		{
			EnterRule_program();
			EnterRule("program", 1);
			TraceIn("program", 1);
			IExpression r = default(IExpression);


			IExpression e = default(IExpression);

			try { DebugEnterRule(GrammarFileName, "program");
				DebugLocation(125, 0);
				try
				{
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:126:3: (e= expression EOF )
					DebugEnterAlt(1);
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:126:3: e= expression EOF
					{
						DebugLocation(126, 4);
						PushFollow(Follow._expression_in_program826);
						e=expression();
						PopFollow();

						DebugLocation(126, 16);
						r = e;
						DebugLocation(126, 25);
						Match(input,EOF,Follow._EOF_in_program830); 

					}

				}
				catch (RecognitionException re)
				{
					ReportError(re);
					Recover(input,re);
				}
				finally
				{
					TraceOut("program", 1);
					LeaveRule("program", 1);
					LeaveRule_program();
				}
				DebugLocation(127, 0);
			} finally { DebugExitRule(GrammarFileName, "program"); }
			return r;

		}
		// $ANTLR end "program"

		partial void EnterRule_expression();
		partial void LeaveRule_expression();

		// $ANTLR start "expression"
		// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:129:1: expression returns [IExpression r] : o= or_expression (e= or_expression_rest[r] )? ;
		[GrammarRule("expression")]
		private IExpression expression()
		{
			EnterRule_expression();
			EnterRule("expression", 2);
			TraceIn("expression", 2);
			IExpression r = default(IExpression);


			IExpression o = default(IExpression);
			IExpression e = default(IExpression);

			try { DebugEnterRule(GrammarFileName, "expression");
				DebugLocation(129, 0);
				try
				{
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:130:3: (o= or_expression (e= or_expression_rest[r] )? )
					DebugEnterAlt(1);
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:130:3: o= or_expression (e= or_expression_rest[r] )?
					{
						DebugLocation(130, 4);
						PushFollow(Follow._or_expression_in_expression845);
						o=or_expression();
						PopFollow();

						DebugLocation(130, 19);
						r = o;
						DebugLocation(130, 28);
						// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:130:28: (e= or_expression_rest[r] )?
						int alt1=2;
						try { DebugEnterSubRule(1);
							try { DebugEnterDecision(1, false);
								int LA1_0 = input.LA(1);

								if ((LA1_0==OR))
								{
									alt1 = 1;
								}
							} finally { DebugExitDecision(1); }
							switch (alt1)
							{
								case 1:
									DebugEnterAlt(1);
									// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:130:29: e= or_expression_rest[r]
								{
									DebugLocation(130, 30);
									PushFollow(Follow._or_expression_rest_in_expression852);
									e=or_expression_rest(r);
									PopFollow();

									DebugLocation(130, 53);
									r = e;

								}
									break;

							}
						} finally { DebugExitSubRule(1); }


					}

				}
				catch (RecognitionException re)
				{
					ReportError(re);
					Recover(input,re);
				}
				finally
				{
					TraceOut("expression", 2);
					LeaveRule("expression", 2);
					LeaveRule_expression();
				}
				DebugLocation(131, 0);
			} finally { DebugExitRule(GrammarFileName, "expression"); }
			return r;

		}
		// $ANTLR end "expression"

		partial void EnterRule_or_expression();
		partial void LeaveRule_or_expression();

		// $ANTLR start "or_expression"
		// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:133:1: or_expression returns [IExpression r] : a= and_expression (e= and_expression_rest[r] )? ;
		[GrammarRule("or_expression")]
		private IExpression or_expression()
		{
			EnterRule_or_expression();
			EnterRule("or_expression", 3);
			TraceIn("or_expression", 3);
			IExpression r = default(IExpression);


			IExpression a = default(IExpression);
			IExpression e = default(IExpression);

			try { DebugEnterRule(GrammarFileName, "or_expression");
				DebugLocation(133, 0);
				try
				{
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:134:3: (a= and_expression (e= and_expression_rest[r] )? )
					DebugEnterAlt(1);
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:134:3: a= and_expression (e= and_expression_rest[r] )?
					{
						DebugLocation(134, 4);
						PushFollow(Follow._and_expression_in_or_expression872);
						a=and_expression();
						PopFollow();

						DebugLocation(134, 20);
						r = a;
						DebugLocation(134, 29);
						// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:134:29: (e= and_expression_rest[r] )?
						int alt2=2;
						try { DebugEnterSubRule(2);
							try { DebugEnterDecision(2, false);
								int LA2_0 = input.LA(1);

								if ((LA2_0==AND))
								{
									alt2 = 1;
								}
							} finally { DebugExitDecision(2); }
							switch (alt2)
							{
								case 1:
									DebugEnterAlt(1);
									// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:134:30: e= and_expression_rest[r]
								{
									DebugLocation(134, 31);
									PushFollow(Follow._and_expression_rest_in_or_expression879);
									e=and_expression_rest(r);
									PopFollow();

									DebugLocation(134, 55);
									r = e;

								}
									break;

							}
						} finally { DebugExitSubRule(2); }


					}

				}
				catch (RecognitionException re)
				{
					ReportError(re);
					Recover(input,re);
				}
				finally
				{
					TraceOut("or_expression", 3);
					LeaveRule("or_expression", 3);
					LeaveRule_or_expression();
				}
				DebugLocation(135, 0);
			} finally { DebugExitRule(GrammarFileName, "or_expression"); }
			return r;

		}
		// $ANTLR end "or_expression"

		partial void EnterRule_or_expression_rest();
		partial void LeaveRule_or_expression_rest();

		// $ANTLR start "or_expression_rest"
		// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:137:1: or_expression_rest[IExpression l] returns [IExpression r] : OR e= expression ;
		[GrammarRule("or_expression_rest")]
		private IExpression or_expression_rest(IExpression l)
		{
			EnterRule_or_expression_rest();
			EnterRule("or_expression_rest", 4);
			TraceIn("or_expression_rest", 4);
			IExpression r = default(IExpression);


			IToken OR1 = default(IToken);
			IExpression e = default(IExpression);

			try { DebugEnterRule(GrammarFileName, "or_expression_rest");
				DebugLocation(137, 0);
				try
				{
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:138:3: ( OR e= expression )
					DebugEnterAlt(1);
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:138:3: OR e= expression
					{
						DebugLocation(138, 3);
						OR1=(IToken)Match(input,OR,Follow._OR_in_or_expression_rest899); 
						DebugLocation(138, 7);
						PushFollow(Follow._expression_in_or_expression_rest903);
						e=expression();
						PopFollow();

						DebugLocation(138, 19);
						r = new IntegerOperator {line = OR1.Line, column = OR1.CharPositionInLine, Left = l, Right = e, Optype = IntegerOp.Or};

					}

				}
				catch (RecognitionException re)
				{
					ReportError(re);
					Recover(input,re);
				}
				finally
				{
					TraceOut("or_expression_rest", 4);
					LeaveRule("or_expression_rest", 4);
					LeaveRule_or_expression_rest();
				}
				DebugLocation(139, 0);
			} finally { DebugExitRule(GrammarFileName, "or_expression_rest"); }
			return r;

		}
		// $ANTLR end "or_expression_rest"

		partial void EnterRule_and_expression();
		partial void LeaveRule_and_expression();

		// $ANTLR start "and_expression"
		// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:141:1: and_expression returns [IExpression r] : a= aritmetic_expression (l= relational_expression[r] )? ;
		[GrammarRule("and_expression")]
		private IExpression and_expression()
		{
			EnterRule_and_expression();
			EnterRule("and_expression", 5);
			TraceIn("and_expression", 5);
			IExpression r = default(IExpression);


			IExpression a = default(IExpression);
			IExpression l = default(IExpression);

			try { DebugEnterRule(GrammarFileName, "and_expression");
				DebugLocation(141, 0);
				try
				{
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:142:3: (a= aritmetic_expression (l= relational_expression[r] )? )
					DebugEnterAlt(1);
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:142:3: a= aritmetic_expression (l= relational_expression[r] )?
					{
						DebugLocation(142, 4);
						PushFollow(Follow._aritmetic_expression_in_and_expression920);
						a=aritmetic_expression();
						PopFollow();

						DebugLocation(142, 26);
						r = a;
						DebugLocation(142, 35);
						// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:142:35: (l= relational_expression[r] )?
						int alt3=2;
						try { DebugEnterSubRule(3);
							try { DebugEnterDecision(3, false);
								switch (input.LA(1))
								{
									case EQUAL:
									{
										alt3 = 1;
									}
										break;
									case NOT_EQUAL:
									{
										alt3 = 1;
									}
										break;
									case GTHAN:
									{
										alt3 = 1;
									}
										break;
									case LTHAN:
									{
										alt3 = 1;
									}
										break;
									case GTHAN_EQUAL:
									{
										alt3 = 1;
									}
										break;
									case LTHAN_EQUAL:
									{
										alt3 = 1;
									}
										break;
								}

							} finally { DebugExitDecision(3); }
							switch (alt3)
							{
								case 1:
									DebugEnterAlt(1);
									// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:142:36: l= relational_expression[r]
								{
									DebugLocation(142, 37);
									PushFollow(Follow._relational_expression_in_and_expression927);
									l=relational_expression(r);
									PopFollow();

									DebugLocation(142, 63);
									r = l;

								}
									break;

							}
						} finally { DebugExitSubRule(3); }


					}

				}
				catch (RecognitionException re)
				{
					ReportError(re);
					Recover(input,re);
				}
				finally
				{
					TraceOut("and_expression", 5);
					LeaveRule("and_expression", 5);
					LeaveRule_and_expression();
				}
				DebugLocation(143, 0);
			} finally { DebugExitRule(GrammarFileName, "and_expression"); }
			return r;

		}
		// $ANTLR end "and_expression"

		partial void EnterRule_and_expression_rest();
		partial void LeaveRule_and_expression_rest();

		// $ANTLR start "and_expression_rest"
		// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:145:1: and_expression_rest[IExpression l] returns [IExpression r] : AND e= or_expression ;
		[GrammarRule("and_expression_rest")]
		private IExpression and_expression_rest(IExpression l)
		{
			EnterRule_and_expression_rest();
			EnterRule("and_expression_rest", 6);
			TraceIn("and_expression_rest", 6);
			IExpression r = default(IExpression);


			IToken AND2 = default(IToken);
			IExpression e = default(IExpression);

			try { DebugEnterRule(GrammarFileName, "and_expression_rest");
				DebugLocation(145, 0);
				try
				{
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:146:3: ( AND e= or_expression )
					DebugEnterAlt(1);
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:146:3: AND e= or_expression
					{
						DebugLocation(146, 3);
						AND2=(IToken)Match(input,AND,Follow._AND_in_and_expression_rest947); 
						DebugLocation(146, 8);
						PushFollow(Follow._or_expression_in_and_expression_rest951);
						e=or_expression();
						PopFollow();

						DebugLocation(146, 23);
						r = new IntegerOperator {line = AND2.Line, column = AND2.CharPositionInLine, Left = l, Right = e, Optype = IntegerOp.And};

					}

				}
				catch (RecognitionException re)
				{
					ReportError(re);
					Recover(input,re);
				}
				finally
				{
					TraceOut("and_expression_rest", 6);
					LeaveRule("and_expression_rest", 6);
					LeaveRule_and_expression_rest();
				}
				DebugLocation(147, 0);
			} finally { DebugExitRule(GrammarFileName, "and_expression_rest"); }
			return r;

		}
		// $ANTLR end "and_expression_rest"

		partial void EnterRule_relational_expression();
		partial void LeaveRule_relational_expression();

		// $ANTLR start "relational_expression"
		// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:149:1: relational_expression[IExpression a] returns [IExpression r] : ( EQUAL b= aritmetic_expression | NOT_EQUAL b= aritmetic_expression | GTHAN b= aritmetic_expression | LTHAN b= aritmetic_expression | GTHAN_EQUAL b= aritmetic_expression | LTHAN_EQUAL b= aritmetic_expression );
		[GrammarRule("relational_expression")]
		private IExpression relational_expression(IExpression a)
		{
			EnterRule_relational_expression();
			EnterRule("relational_expression", 7);
			TraceIn("relational_expression", 7);
			IExpression r = default(IExpression);


			IToken EQUAL3 = default(IToken);
			IToken NOT_EQUAL4 = default(IToken);
			IToken GTHAN5 = default(IToken);
			IToken LTHAN6 = default(IToken);
			IToken GTHAN_EQUAL7 = default(IToken);
			IToken LTHAN_EQUAL8 = default(IToken);
			IExpression b = default(IExpression);

			try { DebugEnterRule(GrammarFileName, "relational_expression");
				DebugLocation(149, 0);
				try
				{
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:150:3: ( EQUAL b= aritmetic_expression | NOT_EQUAL b= aritmetic_expression | GTHAN b= aritmetic_expression | LTHAN b= aritmetic_expression | GTHAN_EQUAL b= aritmetic_expression | LTHAN_EQUAL b= aritmetic_expression )
					int alt4=6;
					try { DebugEnterDecision(4, false);
						switch (input.LA(1))
						{
							case EQUAL:
							{
								alt4 = 1;
							}
								break;
							case NOT_EQUAL:
							{
								alt4 = 2;
							}
								break;
							case GTHAN:
							{
								alt4 = 3;
							}
								break;
							case LTHAN:
							{
								alt4 = 4;
							}
								break;
							case GTHAN_EQUAL:
							{
								alt4 = 5;
							}
								break;
							case LTHAN_EQUAL:
							{
								alt4 = 6;
							}
								break;
							default:
							{
								NoViableAltException nvae = new NoViableAltException("", 4, 0, input);
								DebugRecognitionException(nvae);
								throw nvae;
							}
						}

					} finally { DebugExitDecision(4); }
					switch (alt4)
					{
						case 1:
							DebugEnterAlt(1);
							// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:150:3: EQUAL b= aritmetic_expression
						{
							DebugLocation(150, 3);
							EQUAL3=(IToken)Match(input,EQUAL,Follow._EQUAL_in_relational_expression968); 
							DebugLocation(150, 10);
							PushFollow(Follow._aritmetic_expression_in_relational_expression972);
							b=aritmetic_expression();
							PopFollow();

							DebugLocation(150, 32);
							r = new EqualityOperator {line = EQUAL3.Line, column = EQUAL3.CharPositionInLine, Left = a, Right = b};

						}
							break;
						case 2:
							DebugEnterAlt(2);
							// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:151:3: NOT_EQUAL b= aritmetic_expression
						{
							DebugLocation(151, 3);
							NOT_EQUAL4=(IToken)Match(input,NOT_EQUAL,Follow._NOT_EQUAL_in_relational_expression978); 
							DebugLocation(151, 14);
							PushFollow(Follow._aritmetic_expression_in_relational_expression982);
							b=aritmetic_expression();
							PopFollow();

							DebugLocation(151, 36);
							r = new EqualityOperator {line = NOT_EQUAL4.Line, column = NOT_EQUAL4.CharPositionInLine, Left = a, Right = b, Equal = false };

						}
							break;
						case 3:
							DebugEnterAlt(3);
							// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:152:3: GTHAN b= aritmetic_expression
						{
							DebugLocation(152, 3);
							GTHAN5=(IToken)Match(input,GTHAN,Follow._GTHAN_in_relational_expression988); 
							DebugLocation(152, 10);
							PushFollow(Follow._aritmetic_expression_in_relational_expression992);
							b=aritmetic_expression();
							PopFollow();

							DebugLocation(152, 32);
							r = new GreaterThan {line = GTHAN5.Line, column = GTHAN5.CharPositionInLine, Left = a, Right = b};

						}
							break;
						case 4:
							DebugEnterAlt(4);
							// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:153:3: LTHAN b= aritmetic_expression
						{
							DebugLocation(153, 3);
							LTHAN6=(IToken)Match(input,LTHAN,Follow._LTHAN_in_relational_expression998); 
							DebugLocation(153, 10);
							PushFollow(Follow._aritmetic_expression_in_relational_expression1002);
							b=aritmetic_expression();
							PopFollow();

							DebugLocation(153, 32);
							r = new LessThan {line = LTHAN6.Line, column = LTHAN6.CharPositionInLine, Left = a, Right = b};

						}
							break;
						case 5:
							DebugEnterAlt(5);
							// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:154:3: GTHAN_EQUAL b= aritmetic_expression
						{
							DebugLocation(154, 3);
							GTHAN_EQUAL7=(IToken)Match(input,GTHAN_EQUAL,Follow._GTHAN_EQUAL_in_relational_expression1008); 
							DebugLocation(154, 16);
							PushFollow(Follow._aritmetic_expression_in_relational_expression1012);
							b=aritmetic_expression();
							PopFollow();

							DebugLocation(154, 38);
							r = new GreaterEqualThan {line = GTHAN_EQUAL7.Line, column = GTHAN_EQUAL7.CharPositionInLine, Left = a, Right = b};

						}
							break;
						case 6:
							DebugEnterAlt(6);
							// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:155:3: LTHAN_EQUAL b= aritmetic_expression
						{
							DebugLocation(155, 3);
							LTHAN_EQUAL8=(IToken)Match(input,LTHAN_EQUAL,Follow._LTHAN_EQUAL_in_relational_expression1018); 
							DebugLocation(155, 16);
							PushFollow(Follow._aritmetic_expression_in_relational_expression1022);
							b=aritmetic_expression();
							PopFollow();

							DebugLocation(155, 38);
							r = new LessEqualThan {line = LTHAN_EQUAL8.Line, column = LTHAN_EQUAL8.CharPositionInLine, Left = a, Right = b};

						}
							break;

					}
				}
				catch (RecognitionException re)
				{
					ReportError(re);
					Recover(input,re);
				}
				finally
				{
					TraceOut("relational_expression", 7);
					LeaveRule("relational_expression", 7);
					LeaveRule_relational_expression();
				}
				DebugLocation(156, 0);
			} finally { DebugExitRule(GrammarFileName, "relational_expression"); }
			return r;

		}
		// $ANTLR end "relational_expression"

		partial void EnterRule_aritmetic_expression();
		partial void LeaveRule_aritmetic_expression();

		// $ANTLR start "aritmetic_expression"
		// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:158:1: aritmetic_expression returns [IExpression r] : t= term (a= aritmetic_expression_rest[r] )? ;
		[GrammarRule("aritmetic_expression")]
		private IExpression aritmetic_expression()
		{
			EnterRule_aritmetic_expression();
			EnterRule("aritmetic_expression", 8);
			TraceIn("aritmetic_expression", 8);
			IExpression r = default(IExpression);


			IExpression t = default(IExpression);
			IExpression a = default(IExpression);

			try { DebugEnterRule(GrammarFileName, "aritmetic_expression");
				DebugLocation(158, 0);
				try
				{
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:159:3: (t= term (a= aritmetic_expression_rest[r] )? )
					DebugEnterAlt(1);
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:159:3: t= term (a= aritmetic_expression_rest[r] )?
					{
						DebugLocation(159, 4);
						PushFollow(Follow._term_in_aritmetic_expression1038);
						t=term();
						PopFollow();

						DebugLocation(159, 10);
						r = t;
						DebugLocation(159, 19);
						// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:159:19: (a= aritmetic_expression_rest[r] )?
						int alt5=2;
						try { DebugEnterSubRule(5);
							try { DebugEnterDecision(5, false);
								int LA5_0 = input.LA(1);

								if ((LA5_0==MINUS||LA5_0==PLUS))
								{
									alt5 = 1;
								}
							} finally { DebugExitDecision(5); }
							switch (alt5)
							{
								case 1:
									DebugEnterAlt(1);
									// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:159:20: a= aritmetic_expression_rest[r]
								{
									DebugLocation(159, 21);
									PushFollow(Follow._aritmetic_expression_rest_in_aritmetic_expression1045);
									a=aritmetic_expression_rest(r);
									PopFollow();

									DebugLocation(159, 51);
									r = a;

								}
									break;

							}
						} finally { DebugExitSubRule(5); }


					}

				}
				catch (RecognitionException re)
				{
					ReportError(re);
					Recover(input,re);
				}
				finally
				{
					TraceOut("aritmetic_expression", 8);
					LeaveRule("aritmetic_expression", 8);
					LeaveRule_aritmetic_expression();
				}
				DebugLocation(160, 0);
			} finally { DebugExitRule(GrammarFileName, "aritmetic_expression"); }
			return r;

		}
		// $ANTLR end "aritmetic_expression"

		partial void EnterRule_aritmetic_expression_rest();
		partial void LeaveRule_aritmetic_expression_rest();

		// $ANTLR start "aritmetic_expression_rest"
		// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:162:1: aritmetic_expression_rest[IExpression a] returns [IExpression r] : op= ( MINUS | PLUS ) t= term (e= aritmetic_expression_rest[r] )? ;
		[GrammarRule("aritmetic_expression_rest")]
		private IExpression aritmetic_expression_rest(IExpression a)
		{
			EnterRule_aritmetic_expression_rest();
			EnterRule("aritmetic_expression_rest", 9);
			TraceIn("aritmetic_expression_rest", 9);
			IExpression r = default(IExpression);


			IToken op = default(IToken);
			IExpression t = default(IExpression);
			IExpression e = default(IExpression);

			try { DebugEnterRule(GrammarFileName, "aritmetic_expression_rest");
				DebugLocation(162, 0);
				try
				{
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:163:3: (op= ( MINUS | PLUS ) t= term (e= aritmetic_expression_rest[r] )? )
					DebugEnterAlt(1);
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:163:3: op= ( MINUS | PLUS ) t= term (e= aritmetic_expression_rest[r] )?
					{
						DebugLocation(163, 5);

						op=(IToken)input.LT(1);
						if (input.LA(1)==MINUS||input.LA(1)==PLUS)
						{
							input.Consume();
							state.errorRecovery=false;
						}
						else
						{
							MismatchedSetException mse = new MismatchedSetException(null,input);
							DebugRecognitionException(mse);
							throw mse;
						}

						DebugLocation(164, 3);
						PushFollow(Follow._term_in_aritmetic_expression_rest1079);
						t=term();
						PopFollow();

						DebugLocation(164, 9);
						r = new IntegerOperator {line = op.Line, column = op.CharPositionInLine, Left = a, Right = t, Optype = new IntegerOp((op!=null?op.Text:null)[0])};
						DebugLocation(165, 2);
						// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:165:2: (e= aritmetic_expression_rest[r] )?
						int alt6=2;
						try { DebugEnterSubRule(6);
							try { DebugEnterDecision(6, false);
								int LA6_0 = input.LA(1);

								if ((LA6_0==MINUS||LA6_0==PLUS))
								{
									alt6 = 1;
								}
							} finally { DebugExitDecision(6); }
							switch (alt6)
							{
								case 1:
									DebugEnterAlt(1);
									// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:165:3: e= aritmetic_expression_rest[r]
								{
									DebugLocation(165, 4);
									PushFollow(Follow._aritmetic_expression_rest_in_aritmetic_expression_rest1088);
									e=aritmetic_expression_rest(r);
									PopFollow();

									DebugLocation(165, 34);
									r = e;

								}
									break;

							}
						} finally { DebugExitSubRule(6); }


					}

				}
				catch (RecognitionException re)
				{
					ReportError(re);
					Recover(input,re);
				}
				finally
				{
					TraceOut("aritmetic_expression_rest", 9);
					LeaveRule("aritmetic_expression_rest", 9);
					LeaveRule_aritmetic_expression_rest();
				}
				DebugLocation(166, 0);
			} finally { DebugExitRule(GrammarFileName, "aritmetic_expression_rest"); }
			return r;

		}
		// $ANTLR end "aritmetic_expression_rest"

		partial void EnterRule_term();
		partial void LeaveRule_term();

		// $ANTLR start "term"
		// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:168:1: term returns [IExpression r] : f= factor (a= term_rest[f] )? ;
		[GrammarRule("term")]
		private IExpression term()
		{
			EnterRule_term();
			EnterRule("term", 10);
			TraceIn("term", 10);
			IExpression r = default(IExpression);


			IExpression f = default(IExpression);
			IExpression a = default(IExpression);

			try { DebugEnterRule(GrammarFileName, "term");
				DebugLocation(168, 0);
				try
				{
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:169:2: (f= factor (a= term_rest[f] )? )
					DebugEnterAlt(1);
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:169:2: f= factor (a= term_rest[f] )?
					{
						DebugLocation(169, 3);
						PushFollow(Follow._factor_in_term1107);
						f=factor();
						PopFollow();

						DebugLocation(169, 11);
						r=f;
						DebugLocation(169, 18);
						// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:169:18: (a= term_rest[f] )?
						int alt7=2;
						try { DebugEnterSubRule(7);
							try { DebugEnterDecision(7, false);
								int LA7_0 = input.LA(1);

								if ((LA7_0==DIV||LA7_0==MULT))
								{
									alt7 = 1;
								}
							} finally { DebugExitDecision(7); }
							switch (alt7)
							{
								case 1:
									DebugEnterAlt(1);
									// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:169:19: a= term_rest[f]
								{
									DebugLocation(169, 20);
									PushFollow(Follow._term_rest_in_term1114);
									a=term_rest(f);
									PopFollow();

									DebugLocation(169, 34);
									r=a;

								}
									break;

							}
						} finally { DebugExitSubRule(7); }


					}

				}
				catch (RecognitionException re)
				{
					ReportError(re);
					Recover(input,re);
				}
				finally
				{
					TraceOut("term", 10);
					LeaveRule("term", 10);
					LeaveRule_term();
				}
				DebugLocation(170, 0);
			} finally { DebugExitRule(GrammarFileName, "term"); }
			return r;

		}
		// $ANTLR end "term"

		partial void EnterRule_term_rest();
		partial void LeaveRule_term_rest();

		// $ANTLR start "term_rest"
		// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:172:1: term_rest[IExpression a] returns [IExpression r] : op= ( MULT | DIV ) f= factor (t= term_rest[r] )? ;
		[GrammarRule("term_rest")]
		private IExpression term_rest(IExpression a)
		{
			EnterRule_term_rest();
			EnterRule("term_rest", 11);
			TraceIn("term_rest", 11);
			IExpression r = default(IExpression);


			IToken op = default(IToken);
			IExpression f = default(IExpression);
			IExpression t = default(IExpression);

			try { DebugEnterRule(GrammarFileName, "term_rest");
				DebugLocation(172, 0);
				try
				{
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:173:3: (op= ( MULT | DIV ) f= factor (t= term_rest[r] )? )
					DebugEnterAlt(1);
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:173:3: op= ( MULT | DIV ) f= factor (t= term_rest[r] )?
					{
						DebugLocation(173, 5);

						op=(IToken)input.LT(1);
						if (input.LA(1)==DIV||input.LA(1)==MULT)
						{
							input.Consume();
							state.errorRecovery=false;
						}
						else
						{
							MismatchedSetException mse = new MismatchedSetException(null,input);
							DebugRecognitionException(mse);
							throw mse;
						}

						DebugLocation(174, 3);
						PushFollow(Follow._factor_in_term_rest1146);
						f=factor();
						PopFollow();

						DebugLocation(174, 11);
						r = new IntegerOperator {line = op.Line, column = op.CharPositionInLine, Left = a, Right = f, Optype = new IntegerOp((op!=null?op.Text:null)[0])};
						DebugLocation(175, 2);
						// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:175:2: (t= term_rest[r] )?
						int alt8=2;
						try { DebugEnterSubRule(8);
							try { DebugEnterDecision(8, false);
								int LA8_0 = input.LA(1);

								if ((LA8_0==DIV||LA8_0==MULT))
								{
									alt8 = 1;
								}
							} finally { DebugExitDecision(8); }
							switch (alt8)
							{
								case 1:
									DebugEnterAlt(1);
									// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:175:3: t= term_rest[r]
								{
									DebugLocation(175, 4);
									PushFollow(Follow._term_rest_in_term_rest1154);
									t=term_rest(r);
									PopFollow();

									DebugLocation(175, 18);
									r = t;

								}
									break;

							}
						} finally { DebugExitSubRule(8); }


					}

				}
				catch (RecognitionException re)
				{
					ReportError(re);
					Recover(input,re);
				}
				finally
				{
					TraceOut("term_rest", 11);
					LeaveRule("term_rest", 11);
					LeaveRule_term_rest();
				}
				DebugLocation(176, 0);
			} finally { DebugExitRule(GrammarFileName, "term_rest"); }
			return r;

		}
		// $ANTLR end "term_rest"

		partial void EnterRule_factor();
		partial void LeaveRule_factor();

		// $ANTLR start "factor"
		// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:178:1: factor returns [IExpression r] : (s= STRING |i= INT |n= NIL | MINUS e= expression | L_PARENT (e= expression_sequence )? R_PARENT | IF c= expression THEN t= expression ( ELSE e= expression )? | WHILE e1= expression DO e2= expression | FOR i= ID ASSIGN e1= expression TO e2= expression DO e3= expression | BREAK | LET d= declaration_list_list IN e= expression END |h= lvalue_head );
		[GrammarRule("factor")]
		private IExpression factor()
		{
			EnterRule_factor();
			EnterRule("factor", 12);
			TraceIn("factor", 12);
			IExpression r = default(IExpression);


			IToken s = default(IToken);
			IToken i = default(IToken);
			IToken n = default(IToken);
			IToken MINUS9 = default(IToken);
			IToken IF10 = default(IToken);
			IToken WHILE11 = default(IToken);
			IToken FOR12 = default(IToken);
			IToken BREAK13 = default(IToken);
			IToken LET14 = default(IToken);
			IExpression e = default(IExpression);
			IExpression c = default(IExpression);
			IExpression t = default(IExpression);
			IExpression e1 = default(IExpression);
			IExpression e2 = default(IExpression);
			IExpression e3 = default(IExpression);
			List<IDeclarationList<IDeclaration>> d = default(List<IDeclarationList<IDeclaration>>);
			IExpression h = default(IExpression);

			try { DebugEnterRule(GrammarFileName, "factor");
				DebugLocation(178, 0);
				try
				{
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:179:3: (s= STRING |i= INT |n= NIL | MINUS e= expression | L_PARENT (e= expression_sequence )? R_PARENT | IF c= expression THEN t= expression ( ELSE e= expression )? | WHILE e1= expression DO e2= expression | FOR i= ID ASSIGN e1= expression TO e2= expression DO e3= expression | BREAK | LET d= declaration_list_list IN e= expression END |h= lvalue_head )
					int alt11=11;
					try { DebugEnterDecision(11, false);
						switch (input.LA(1))
						{
							case STRING:
							{
								alt11 = 1;
							}
								break;
							case INT:
							{
								alt11 = 2;
							}
								break;
							case NIL:
							{
								alt11 = 3;
							}
								break;
							case MINUS:
							{
								alt11 = 4;
							}
								break;
							case L_PARENT:
							{
								alt11 = 5;
							}
								break;
							case IF:
							{
								alt11 = 6;
							}
								break;
							case WHILE:
							{
								alt11 = 7;
							}
								break;
							case FOR:
							{
								alt11 = 8;
							}
								break;
							case BREAK:
							{
								alt11 = 9;
							}
								break;
							case LET:
							{
								alt11 = 10;
							}
								break;
							case ID:
							{
								alt11 = 11;
							}
								break;
							default:
							{
								NoViableAltException nvae = new NoViableAltException("", 11, 0, input);
								DebugRecognitionException(nvae);
								throw nvae;
							}
						}

					} finally { DebugExitDecision(11); }
					switch (alt11)
					{
						case 1:
							DebugEnterAlt(1);
							// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:179:3: s= STRING
						{
							DebugLocation(179, 4);
							s=(IToken)Match(input,STRING,Follow._STRING_in_factor1174); 
							DebugLocation(179, 12);
							r = new StringConstant{Lex = (s!=null?s.Text:null), line = s.Line, column = s.CharPositionInLine};

						}
							break;
						case 2:
							DebugEnterAlt(2);
							// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:180:3: i= INT
						{
							DebugLocation(180, 4);
							i=(IToken)Match(input,INT,Follow._INT_in_factor1183); 
							DebugLocation(180, 9);
							r = new IntegerConstant{Lex = (i!=null?i.Text:null), line = i.Line, column = i.CharPositionInLine};

						}
							break;
						case 3:
							DebugEnterAlt(3);
							// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:181:3: n= NIL
						{
							DebugLocation(181, 4);
							n=(IToken)Match(input,NIL,Follow._NIL_in_factor1191); 
							DebugLocation(181, 9);
							r = new NilConstant{line = n.Line, column = n.CharPositionInLine};

						}
							break;
						case 4:
							DebugEnterAlt(4);
							// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:182:3: MINUS e= expression
						{
							DebugLocation(182, 3);
							MINUS9=(IToken)Match(input,MINUS,Follow._MINUS_in_factor1197); 
							DebugLocation(182, 10);
							PushFollow(Follow._expression_in_factor1201);
							e=expression();
							PopFollow();

							DebugLocation(182, 22);
							r = new Neg{line = MINUS9.Line, column = MINUS9.CharPositionInLine, Operand = e};

						}
							break;
						case 5:
							DebugEnterAlt(5);
							// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:183:3: L_PARENT (e= expression_sequence )? R_PARENT
						{
							DebugLocation(183, 3);
							Match(input,L_PARENT,Follow._L_PARENT_in_factor1207); 
							DebugLocation(183, 12);
							// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:183:12: (e= expression_sequence )?
							int alt9=2;
							try { DebugEnterSubRule(9);
								try { DebugEnterDecision(9, false);
									int LA9_0 = input.LA(1);

									if ((LA9_0==BREAK||LA9_0==FOR||(LA9_0>=ID && LA9_0<=IF)||(LA9_0>=INT && LA9_0<=LET)||(LA9_0>=L_PARENT && LA9_0<=MINUS)||LA9_0==NIL||LA9_0==STRING||LA9_0==WHILE))
									{
										alt9 = 1;
									}
								} finally { DebugExitDecision(9); }
								switch (alt9)
								{
									case 1:
										DebugEnterAlt(1);
										// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:183:13: e= expression_sequence
									{
										DebugLocation(183, 14);
										PushFollow(Follow._expression_sequence_in_factor1212);
										e=expression_sequence();
										PopFollow();

										DebugLocation(183, 35);
										r = e;

									}
										break;

								}
							} finally { DebugExitSubRule(9); }

							DebugLocation(183, 46);
							Match(input,R_PARENT,Follow._R_PARENT_in_factor1218); 

						}
							break;
						case 6:
							DebugEnterAlt(6);
							// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:184:3: IF c= expression THEN t= expression ( ELSE e= expression )?
						{
							DebugLocation(184, 3);
							IF10=(IToken)Match(input,IF,Follow._IF_in_factor1222); 
							DebugLocation(184, 7);
							PushFollow(Follow._expression_in_factor1226);
							c=expression();
							PopFollow();

							DebugLocation(184, 19);
							Match(input,THEN,Follow._THEN_in_factor1228); 
							DebugLocation(184, 25);
							PushFollow(Follow._expression_in_factor1232);
							t=expression();
							PopFollow();

							DebugLocation(184, 37);
							r = new IfThenElse {line = IF10.Line, column = IF10.CharPositionInLine, If = c, Then = t};
							DebugLocation(184, 128);
							// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:184:128: ( ELSE e= expression )?
							int alt10=2;
							try { DebugEnterSubRule(10);
								try { DebugEnterDecision(10, false);
									int LA10_0 = input.LA(1);

									if ((LA10_0==ELSE))
									{
										alt10 = 1;
									}
								} finally { DebugExitDecision(10); }
								switch (alt10)
								{
									case 1:
										DebugEnterAlt(1);
										// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:184:129: ELSE e= expression
									{
										DebugLocation(184, 129);
										Match(input,ELSE,Follow._ELSE_in_factor1237); 
										DebugLocation(184, 135);
										PushFollow(Follow._expression_in_factor1241);
										e=expression();
										PopFollow();

										DebugLocation(184, 147);
										((IfThenElse)r).Else = e;

									}
										break;

								}
							} finally { DebugExitSubRule(10); }


						}
							break;
						case 7:
							DebugEnterAlt(7);
							// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:185:3: WHILE e1= expression DO e2= expression
						{
							DebugLocation(185, 3);
							WHILE11=(IToken)Match(input,WHILE,Follow._WHILE_in_factor1249); 
							DebugLocation(185, 11);
							PushFollow(Follow._expression_in_factor1253);
							e1=expression();
							PopFollow();

							DebugLocation(185, 23);
							Match(input,DO,Follow._DO_in_factor1255); 
							DebugLocation(185, 28);
							PushFollow(Follow._expression_in_factor1259);
							e2=expression();
							PopFollow();

							DebugLocation(185, 40);
							r = new While{line = WHILE11.Line, column = WHILE11.CharPositionInLine, Condition = e1, Body = e2};

						}
							break;
						case 8:
							DebugEnterAlt(8);
							// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:186:3: FOR i= ID ASSIGN e1= expression TO e2= expression DO e3= expression
						{
							DebugLocation(186, 3);
							FOR12=(IToken)Match(input,FOR,Follow._FOR_in_factor1265); 
							DebugLocation(186, 8);
							i=(IToken)Match(input,ID,Follow._ID_in_factor1269); 
							DebugLocation(186, 12);
							Match(input,ASSIGN,Follow._ASSIGN_in_factor1271); 
							DebugLocation(186, 21);
							PushFollow(Follow._expression_in_factor1275);
							e1=expression();
							PopFollow();

							DebugLocation(186, 33);
							Match(input,TO,Follow._TO_in_factor1277); 
							DebugLocation(186, 38);
							PushFollow(Follow._expression_in_factor1281);
							e2=expression();
							PopFollow();

							DebugLocation(186, 50);
							Match(input,DO,Follow._DO_in_factor1283); 
							DebugLocation(186, 55);
							PushFollow(Follow._expression_in_factor1287);
							e3=expression();
							PopFollow();

							DebugLocation(186, 67);
							r = new BoundedFor{line = FOR12.Line, column = FOR12.CharPositionInLine, VarName = (i!=null?i.Text:null), From = e1, To = e2, Body = e3};

						}
							break;
						case 9:
							DebugEnterAlt(9);
							// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:187:3: BREAK
						{
							DebugLocation(187, 3);
							BREAK13=(IToken)Match(input,BREAK,Follow._BREAK_in_factor1293); 
							DebugLocation(187, 9);
							r = new Break{line = BREAK13.Line, column = BREAK13.CharPositionInLine};

						}
							break;
						case 10:
							DebugEnterAlt(10);
							// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:188:3: LET d= declaration_list_list IN e= expression END
						{
							DebugLocation(188, 3);
							LET14=(IToken)Match(input,LET,Follow._LET_in_factor1299); 
							DebugLocation(188, 8);
							PushFollow(Follow._declaration_list_list_in_factor1303);
							d=declaration_list_list();
							PopFollow();

							DebugLocation(188, 31);
							Match(input,IN,Follow._IN_in_factor1305); 
							DebugLocation(188, 35);
							PushFollow(Follow._expression_in_factor1309);
							e=expression();
							PopFollow();

							DebugLocation(188, 47);
							Match(input,END,Follow._END_in_factor1311); 
							DebugLocation(188, 51);
							r = new Let{line = LET14.Line, column = LET14.CharPositionInLine, Declarations = d, Body = e};

						}
							break;
						case 11:
							DebugEnterAlt(11);
							// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:189:3: h= lvalue_head
						{
							DebugLocation(189, 4);
							PushFollow(Follow._lvalue_head_in_factor1319);
							h=lvalue_head();
							PopFollow();

							DebugLocation(189, 17);
							r = h;

						}
							break;

					}
				}
				catch (RecognitionException re)
				{
					ReportError(re);
					Recover(input,re);
				}
				finally
				{
					TraceOut("factor", 12);
					LeaveRule("factor", 12);
					LeaveRule_factor();
				}
				DebugLocation(190, 0);
			} finally { DebugExitRule(GrammarFileName, "factor"); }
			return r;

		}
		// $ANTLR end "factor"

		partial void EnterRule_lvalue_head();
		partial void LeaveRule_lvalue_head();

		// $ANTLR start "lvalue_head"
		// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:192:1: lvalue_head returns [IExpression r] : i= ID (ins= invoke[$i.text, $i.Line, $i.CharPositionInLine] | L_BRACKETS e1= expression R_BRACKETS a= array[$i.text, e1, $i.Line, $i.CharPositionInLine, $L_BRACKETS.Line, $L_BRACKETS.CharPositionInLine] | DOT i2= ID l= dot[$i.text, $i2.text, $i.Line, $i.CharPositionInLine, $i2.Line, $i2.CharPositionInLine] )? ;
		[GrammarRule("lvalue_head")]
		private IExpression lvalue_head()
		{
			EnterRule_lvalue_head();
			EnterRule("lvalue_head", 13);
			TraceIn("lvalue_head", 13);
			IExpression r = default(IExpression);


			IToken i = default(IToken);
			IToken i2 = default(IToken);
			IToken L_BRACKETS15 = default(IToken);
			IExpression ins = default(IExpression);
			IExpression e1 = default(IExpression);
			IExpression a = default(IExpression);
			IExpression l = default(IExpression);

			try { DebugEnterRule(GrammarFileName, "lvalue_head");
				DebugLocation(192, 0);
				try
				{
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:194:3: (i= ID (ins= invoke[$i.text, $i.Line, $i.CharPositionInLine] | L_BRACKETS e1= expression R_BRACKETS a= array[$i.text, e1, $i.Line, $i.CharPositionInLine, $L_BRACKETS.Line, $L_BRACKETS.CharPositionInLine] | DOT i2= ID l= dot[$i.text, $i2.text, $i.Line, $i.CharPositionInLine, $i2.Line, $i2.CharPositionInLine] )? )
					DebugEnterAlt(1);
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:194:3: i= ID (ins= invoke[$i.text, $i.Line, $i.CharPositionInLine] | L_BRACKETS e1= expression R_BRACKETS a= array[$i.text, e1, $i.Line, $i.CharPositionInLine, $L_BRACKETS.Line, $L_BRACKETS.CharPositionInLine] | DOT i2= ID l= dot[$i.text, $i2.text, $i.Line, $i.CharPositionInLine, $i2.Line, $i2.CharPositionInLine] )?
					{
						DebugLocation(194, 4);
						i=(IToken)Match(input,ID,Follow._ID_in_lvalue_head1340); 
						DebugLocation(194, 8);
						// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:194:8: (ins= invoke[$i.text, $i.Line, $i.CharPositionInLine] | L_BRACKETS e1= expression R_BRACKETS a= array[$i.text, e1, $i.Line, $i.CharPositionInLine, $L_BRACKETS.Line, $L_BRACKETS.CharPositionInLine] | DOT i2= ID l= dot[$i.text, $i2.text, $i.Line, $i.CharPositionInLine, $i2.Line, $i2.CharPositionInLine] )?
						int alt12=4;
						try { DebugEnterSubRule(12);
							try { DebugEnterDecision(12, false);
								switch (input.LA(1))
								{
									case L_KEY:
									case L_PARENT:
									{
										alt12 = 1;
									}
										break;
									case L_BRACKETS:
									{
										alt12 = 2;
									}
										break;
									case DOT:
									{
										alt12 = 3;
									}
										break;
								}

							} finally { DebugExitDecision(12); }
							switch (alt12)
							{
								case 1:
									DebugEnterAlt(1);
									// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:194:9: ins= invoke[$i.text, $i.Line, $i.CharPositionInLine]
								{
									DebugLocation(194, 12);
									PushFollow(Follow._invoke_in_lvalue_head1345);
									ins=invoke((i!=null?i.Text:null), i.Line, i.CharPositionInLine);
									PopFollow();

									DebugLocation(194, 61);
									r = ins;

								}
									break;
								case 2:
									DebugEnterAlt(2);
									// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:195:5: L_BRACKETS e1= expression R_BRACKETS a= array[$i.text, e1, $i.Line, $i.CharPositionInLine, $L_BRACKETS.Line, $L_BRACKETS.CharPositionInLine]
								{
									DebugLocation(195, 5);
									L_BRACKETS15=(IToken)Match(input,L_BRACKETS,Follow._L_BRACKETS_in_lvalue_head1355); 
									DebugLocation(195, 18);
									PushFollow(Follow._expression_in_lvalue_head1359);
									e1=expression();
									PopFollow();

									DebugLocation(195, 30);
									Match(input,R_BRACKETS,Follow._R_BRACKETS_in_lvalue_head1361); 
									DebugLocation(195, 42);
									PushFollow(Follow._array_in_lvalue_head1365);
									a=array((i!=null?i.Text:null), e1, i.Line, i.CharPositionInLine, L_BRACKETS15.Line, L_BRACKETS15.CharPositionInLine);
									PopFollow();

									DebugLocation(195, 144);
									r=a;

								}
									break;
								case 3:
									DebugEnterAlt(3);
									// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:196:5: DOT i2= ID l= dot[$i.text, $i2.text, $i.Line, $i.CharPositionInLine, $i2.Line, $i2.CharPositionInLine]
								{
									DebugLocation(196, 5);
									Match(input,DOT,Follow._DOT_in_lvalue_head1374); 
									DebugLocation(196, 11);
									i2=(IToken)Match(input,ID,Follow._ID_in_lvalue_head1378); 
									DebugLocation(196, 16);
									PushFollow(Follow._dot_in_lvalue_head1382);
									l=dot((i!=null?i.Text:null), (i2!=null?i2.Text:null), i.Line, i.CharPositionInLine, i2.Line, i2.CharPositionInLine);
									PopFollow();

									DebugLocation(196, 106);
									r = l;

								}
									break;

							}
						} finally { DebugExitSubRule(12); }


					}

					r = r ??  new Var {Name = (i!=null?i.Text:null), line = i.Line, column = i.CharPositionInLine};
				}
				catch (RecognitionException re)
				{
					ReportError(re);
					Recover(input,re);
				}
				finally
				{
					TraceOut("lvalue_head", 13);
					LeaveRule("lvalue_head", 13);
					LeaveRule_lvalue_head();
				}
				DebugLocation(197, 0);
			} finally { DebugExitRule(GrammarFileName, "lvalue_head"); }
			return r;

		}
		// $ANTLR end "lvalue_head"

		partial void EnterRule_invoke();
		partial void LeaveRule_invoke();

		// $ANTLR start "invoke"
		// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:199:1: invoke[string id, int l, int c] returns [IExpression r] : ( L_PARENT (a= arg_list )? R_PARENT | L_KEY (f= field_list )? R_KEY );
		[GrammarRule("invoke")]
		private IExpression invoke(string id, int l, int c)
		{
			EnterRule_invoke();
			EnterRule("invoke", 14);
			TraceIn("invoke", 14);
			IExpression r = default(IExpression);


			List<IExpression> a = default(List<IExpression>);
			List<Tuple<string, IExpression>> f = default(List<Tuple<string, IExpression>>);

			try { DebugEnterRule(GrammarFileName, "invoke");
				DebugLocation(199, 0);
				try
				{
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:200:3: ( L_PARENT (a= arg_list )? R_PARENT | L_KEY (f= field_list )? R_KEY )
					int alt15=2;
					try { DebugEnterDecision(15, false);
						int LA15_0 = input.LA(1);

						if ((LA15_0==L_PARENT))
						{
							alt15 = 1;
						}
						else if ((LA15_0==L_KEY))
						{
							alt15 = 2;
						}
						else
						{
							NoViableAltException nvae = new NoViableAltException("", 15, 0, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					} finally { DebugExitDecision(15); }
					switch (alt15)
					{
						case 1:
							DebugEnterAlt(1);
							// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:200:3: L_PARENT (a= arg_list )? R_PARENT
						{
							DebugLocation(200, 3);
							Match(input,L_PARENT,Follow._L_PARENT_in_invoke1403); 
							DebugLocation(200, 13);
							// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:200:13: (a= arg_list )?
							int alt13=2;
							try { DebugEnterSubRule(13);
								try { DebugEnterDecision(13, false);
									int LA13_0 = input.LA(1);

									if ((LA13_0==BREAK||LA13_0==FOR||(LA13_0>=ID && LA13_0<=IF)||(LA13_0>=INT && LA13_0<=LET)||(LA13_0>=L_PARENT && LA13_0<=MINUS)||LA13_0==NIL||LA13_0==STRING||LA13_0==WHILE))
									{
										alt13 = 1;
									}
								} finally { DebugExitDecision(13); }
								switch (alt13)
								{
									case 1:
										DebugEnterAlt(1);
										// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:200:13: a= arg_list
									{
										DebugLocation(200, 13);
										PushFollow(Follow._arg_list_in_invoke1407);
										a=arg_list();
										PopFollow();


									}
										break;

								}
							} finally { DebugExitSubRule(13); }

							DebugLocation(200, 24);
							Match(input,R_PARENT,Follow._R_PARENT_in_invoke1410); 
							DebugLocation(200, 33);
							r = new Call{line = l, column = c, Arguments = a ?? new List<IExpression>() , FunctionName = id};

						}
							break;
						case 2:
							DebugEnterAlt(2);
							// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:201:3: L_KEY (f= field_list )? R_KEY
						{
							DebugLocation(201, 3);
							Match(input,L_KEY,Follow._L_KEY_in_invoke1416); 
							DebugLocation(201, 10);
							// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:201:10: (f= field_list )?
							int alt14=2;
							try { DebugEnterSubRule(14);
								try { DebugEnterDecision(14, false);
									int LA14_0 = input.LA(1);

									if ((LA14_0==ID))
									{
										alt14 = 1;
									}
								} finally { DebugExitDecision(14); }
								switch (alt14)
								{
									case 1:
										DebugEnterAlt(1);
										// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:201:10: f= field_list
									{
										DebugLocation(201, 10);
										PushFollow(Follow._field_list_in_invoke1420);
										f=field_list();
										PopFollow();


									}
										break;

								}
							} finally { DebugExitSubRule(14); }

							DebugLocation(201, 23);
							Match(input,R_KEY,Follow._R_KEY_in_invoke1423); 
							DebugLocation(201, 29);
							r = new RecordCreation{line = l, column = c, Members = f ?? new List<Tuple<string, IExpression>>(), Name = id};

						}
							break;

					}
				}
				catch (RecognitionException re)
				{
					ReportError(re);
					Recover(input,re);
				}
				finally
				{
					TraceOut("invoke", 14);
					LeaveRule("invoke", 14);
					LeaveRule_invoke();
				}
				DebugLocation(202, 0);
			} finally { DebugExitRule(GrammarFileName, "invoke"); }
			return r;

		}
		// $ANTLR end "invoke"

		partial void EnterRule_array();
		partial void LeaveRule_array();

		// $ANTLR start "array"
		// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:204:1: array[string id, IExpression e1, int l, int c, int bl, int bc] returns [IExpression r] : ( OF e2= expression |e2= lvalue[new ArrayAccess {Array = new Var {Name = id, line = l, column = c}, Indexer = e1, line = bl, column = bc}] );
		[GrammarRule("array")]
		private IExpression array(string id, IExpression e1, int l, int c, int bl, int bc)
		{
			EnterRule_array();
			EnterRule("array", 15);
			TraceIn("array", 15);
			IExpression r = default(IExpression);


			IExpression e2 = default(IExpression);

			try { DebugEnterRule(GrammarFileName, "array");
				DebugLocation(204, 0);
				try
				{
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:205:3: ( OF e2= expression |e2= lvalue[new ArrayAccess {Array = new Var {Name = id, line = l, column = c}, Indexer = e1, line = bl, column = bc}] )
					int alt16=2;
					try { DebugEnterDecision(16, false);
						int LA16_0 = input.LA(1);

						if ((LA16_0==OF))
						{
							alt16 = 1;
						}
						else if ((LA16_0==EOF||LA16_0==AND||LA16_0==ASSIGN||LA16_0==COMMA||(LA16_0>=DIV && LA16_0<=DOT)||(LA16_0>=ELSE && LA16_0<=EQUAL)||(LA16_0>=FUNCTION && LA16_0<=GTHAN_EQUAL)||LA16_0==IN||(LA16_0>=LTHAN && LA16_0<=L_BRACKETS)||(LA16_0>=MINUS && LA16_0<=MULT)||LA16_0==NOT_EQUAL||(LA16_0>=OR && LA16_0<=SEMICOLON)||(LA16_0>=THEN && LA16_0<=VAR)))
						{
							alt16 = 2;
						}
						else
						{
							NoViableAltException nvae = new NoViableAltException("", 16, 0, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					} finally { DebugExitDecision(16); }
					switch (alt16)
					{
						case 1:
							DebugEnterAlt(1);
							// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:205:3: OF e2= expression
						{
							DebugLocation(205, 3);
							Match(input,OF,Follow._OF_in_array1440); 
							DebugLocation(205, 8);
							PushFollow(Follow._expression_in_array1444);
							e2=expression();
							PopFollow();

							DebugLocation(205, 20);
							r = new ArrayCreation{line = l, column = c, Length = e1, Init = e2, ArrayOf = id};

						}
							break;
						case 2:
							DebugEnterAlt(2);
							// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:206:3: e2= lvalue[new ArrayAccess {Array = new Var {Name = id, line = l, column = c}, Indexer = e1, line = bl, column = bc}]
						{
							DebugLocation(206, 5);
							PushFollow(Follow._lvalue_in_array1452);
							e2=lvalue(new ArrayAccess {Array = new Var {Name = id, line = l, column = c}, Indexer = e1, line = bl, column = bc});
							PopFollow();

							DebugLocation(206, 120);
							r = e2;

						}
							break;

					}
				}
				catch (RecognitionException re)
				{
					ReportError(re);
					Recover(input,re);
				}
				finally
				{
					TraceOut("array", 15);
					LeaveRule("array", 15);
					LeaveRule_array();
				}
				DebugLocation(207, 0);
			} finally { DebugExitRule(GrammarFileName, "array"); }
			return r;

		}
		// $ANTLR end "array"

		partial void EnterRule_dot();
		partial void LeaveRule_dot();

		// $ANTLR start "dot"
		// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:209:1: dot[string idr, string idm, int l, int c, int dl, int dc] returns [IExpression r] : e2= lvalue[new MemberAccess {MemberName = idm, Record = new Var {Name = idr, line = l, column = c}, line = dl, column = dc}] ;
		[GrammarRule("dot")]
		private IExpression dot(string idr, string idm, int l, int c, int dl, int dc)
		{
			EnterRule_dot();
			EnterRule("dot", 16);
			TraceIn("dot", 16);
			IExpression r = default(IExpression);


			IExpression e2 = default(IExpression);

			try { DebugEnterRule(GrammarFileName, "dot");
				DebugLocation(209, 0);
				try
				{
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:210:3: (e2= lvalue[new MemberAccess {MemberName = idm, Record = new Var {Name = idr, line = l, column = c}, line = dl, column = dc}] )
					DebugEnterAlt(1);
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:210:3: e2= lvalue[new MemberAccess {MemberName = idm, Record = new Var {Name = idr, line = l, column = c}, line = dl, column = dc}]
					{
						DebugLocation(210, 5);
						PushFollow(Follow._lvalue_in_dot1472);
						e2=lvalue(new MemberAccess {MemberName = idm, Record = new Var {Name = idr, line = l, column = c}, line = dl, column = dc});
						PopFollow();

						DebugLocation(210, 128);
						r = e2;

					}

				}
				catch (RecognitionException re)
				{
					ReportError(re);
					Recover(input,re);
				}
				finally
				{
					TraceOut("dot", 16);
					LeaveRule("dot", 16);
					LeaveRule_dot();
				}
				DebugLocation(211, 0);
			} finally { DebugExitRule(GrammarFileName, "dot"); }
			return r;

		}
		// $ANTLR end "dot"

		partial void EnterRule_lvalue();
		partial void LeaveRule_lvalue();

		// $ANTLR start "lvalue"
		// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:213:1: lvalue[ILValue var] returns [IExpression r] : ( DOT id= ID | L_BRACKETS indx= expression R_BRACKETS )* ( ASSIGN e= expression )? ;
		[GrammarRule("lvalue")]
		private IExpression lvalue(ILValue var)
		{
			EnterRule_lvalue();
			EnterRule("lvalue", 17);
			TraceIn("lvalue", 17);
			IExpression r = default(IExpression);


			IToken id = default(IToken);
			IToken DOT16 = default(IToken);
			IToken L_BRACKETS17 = default(IToken);
			IToken ASSIGN18 = default(IToken);
			IExpression indx = default(IExpression);
			IExpression e = default(IExpression);

			try { DebugEnterRule(GrammarFileName, "lvalue");
				DebugLocation(213, 0);
				try
				{
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:215:3: ( ( DOT id= ID | L_BRACKETS indx= expression R_BRACKETS )* ( ASSIGN e= expression )? )
					DebugEnterAlt(1);
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:215:3: ( DOT id= ID | L_BRACKETS indx= expression R_BRACKETS )* ( ASSIGN e= expression )?
					{
						DebugLocation(215, 3);
						// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:215:3: ( DOT id= ID | L_BRACKETS indx= expression R_BRACKETS )*
						try { DebugEnterSubRule(17);
							while (true)
							{
								int alt17=3;
								try { DebugEnterDecision(17, false);
									int LA17_0 = input.LA(1);

									if ((LA17_0==DOT))
									{
										alt17 = 1;
									}
									else if ((LA17_0==L_BRACKETS))
									{
										alt17 = 2;
									}


								} finally { DebugExitDecision(17); }
								switch ( alt17 )
								{
									case 1:
										DebugEnterAlt(1);
										// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:215:4: DOT id= ID
									{
										DebugLocation(215, 4);
										DOT16=(IToken)Match(input,DOT,Follow._DOT_in_lvalue1496); 
										DebugLocation(215, 10);
										id=(IToken)Match(input,ID,Follow._ID_in_lvalue1500); 
										DebugLocation(215, 14);
										var = new MemberAccess {MemberName = (id!=null?id.Text:null), Record = var, line = DOT16.Line, column = DOT16.CharPositionInLine};

									}
										break;
									case 2:
										DebugEnterAlt(2);
										// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:216:4: L_BRACKETS indx= expression R_BRACKETS
									{
										DebugLocation(216, 4);
										L_BRACKETS17=(IToken)Match(input,L_BRACKETS,Follow._L_BRACKETS_in_lvalue1508); 
										DebugLocation(216, 19);
										PushFollow(Follow._expression_in_lvalue1512);
										indx=expression();
										PopFollow();

										DebugLocation(216, 31);
										Match(input,R_BRACKETS,Follow._R_BRACKETS_in_lvalue1514); 
										DebugLocation(216, 42);
										var = new ArrayAccess {Array = var, Indexer = indx, line = L_BRACKETS17.Line, column = L_BRACKETS17.CharPositionInLine};

									}
										break;

									default:
										goto loop17;
								}
							}

							loop17:
							;

						} finally { DebugExitSubRule(17); }

						DebugLocation(217, 2);
						// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:217:2: ( ASSIGN e= expression )?
						int alt18=2;
						try { DebugEnterSubRule(18);
							try { DebugEnterDecision(18, false);
								int LA18_0 = input.LA(1);

								if ((LA18_0==ASSIGN))
								{
									alt18 = 1;
								}
							} finally { DebugExitDecision(18); }
							switch (alt18)
							{
								case 1:
									DebugEnterAlt(1);
									// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:217:3: ASSIGN e= expression
								{
									DebugLocation(217, 3);
									ASSIGN18=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_lvalue1524); 
									DebugLocation(217, 11);
									PushFollow(Follow._expression_in_lvalue1528);
									e=expression();
									PopFollow();

									DebugLocation(217, 23);
									r = new Assign {Target = var, Source = e, line = ASSIGN18.Line, column = ASSIGN18.CharPositionInLine};

								}
									break;

							}
						} finally { DebugExitSubRule(18); }


					}

					r = r ?? var; 
				}
				catch (RecognitionException re)
				{
					ReportError(re);
					Recover(input,re);
				}
				finally
				{
					TraceOut("lvalue", 17);
					LeaveRule("lvalue", 17);
					LeaveRule_lvalue();
				}
				DebugLocation(218, 0);
			} finally { DebugExitRule(GrammarFileName, "lvalue"); }
			return r;

		}
		// $ANTLR end "lvalue"

		partial void EnterRule_arg_list();
		partial void LeaveRule_arg_list();

		// $ANTLR start "arg_list"
		// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:220:1: arg_list returns [List<IExpression> r] : e= expression ( COMMA e1= expression )* ;
		[GrammarRule("arg_list")]
		private List<IExpression> arg_list()
		{
			EnterRule_arg_list();
			EnterRule("arg_list", 18);
			TraceIn("arg_list", 18);
			List<IExpression> r = default(List<IExpression>);


			IExpression e = default(IExpression);
			IExpression e1 = default(IExpression);


			r =  new List<IExpression>();

			try { DebugEnterRule(GrammarFileName, "arg_list");
				DebugLocation(220, 0);
				try
				{
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:225:3: (e= expression ( COMMA e1= expression )* )
					DebugEnterAlt(1);
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:225:3: e= expression ( COMMA e1= expression )*
					{
						DebugLocation(225, 4);
						PushFollow(Follow._expression_in_arg_list1552);
						e=expression();
						PopFollow();

						DebugLocation(225, 16);
						r.Add(e);
						DebugLocation(225, 28);
						// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:225:28: ( COMMA e1= expression )*
						try { DebugEnterSubRule(19);
							while (true)
							{
								int alt19=2;
								try { DebugEnterDecision(19, false);
									int LA19_0 = input.LA(1);

									if ((LA19_0==COMMA))
									{
										alt19 = 1;
									}


								} finally { DebugExitDecision(19); }
								switch ( alt19 )
								{
									case 1:
										DebugEnterAlt(1);
										// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:225:29: COMMA e1= expression
									{
										DebugLocation(225, 29);
										Match(input,COMMA,Follow._COMMA_in_arg_list1557); 
										DebugLocation(225, 37);
										PushFollow(Follow._expression_in_arg_list1562);
										e1=expression();
										PopFollow();

										DebugLocation(225, 50);
										r.Add(e1);

									}
										break;

									default:
										goto loop19;
								}
							}

							loop19:
							;

						} finally { DebugExitSubRule(19); }


					}

				}
				catch (RecognitionException re)
				{
					ReportError(re);
					Recover(input,re);
				}
				finally
				{
					TraceOut("arg_list", 18);
					LeaveRule("arg_list", 18);
					LeaveRule_arg_list();
				}
				DebugLocation(226, 0);
			} finally { DebugExitRule(GrammarFileName, "arg_list"); }
			return r;

		}
		// $ANTLR end "arg_list"

		partial void EnterRule_field_list();
		partial void LeaveRule_field_list();

		// $ANTLR start "field_list"
		// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:228:1: field_list returns [List<Tuple<string, IExpression>> r] : i= ID ASSIGN e= expression ( COMMA i= ID ASSIGN e= expression )* ;
		[GrammarRule("field_list")]
		private List<Tuple<string, IExpression>> field_list()
		{
			EnterRule_field_list();
			EnterRule("field_list", 19);
			TraceIn("field_list", 19);
			List<Tuple<string, IExpression>> r = default(List<Tuple<string, IExpression>>);


			IToken i = default(IToken);
			IExpression e = default(IExpression);


			r = new List<Tuple<string, IExpression>>();

			try { DebugEnterRule(GrammarFileName, "field_list");
				DebugLocation(228, 0);
				try
				{
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:233:3: (i= ID ASSIGN e= expression ( COMMA i= ID ASSIGN e= expression )* )
					DebugEnterAlt(1);
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:233:3: i= ID ASSIGN e= expression ( COMMA i= ID ASSIGN e= expression )*
					{
						DebugLocation(233, 4);
						i=(IToken)Match(input,ID,Follow._ID_in_field_list1585); 
						DebugLocation(233, 8);
						Match(input,ASSIGN,Follow._ASSIGN_in_field_list1587); 
						DebugLocation(233, 16);
						PushFollow(Follow._expression_in_field_list1591);
						e=expression();
						PopFollow();

						DebugLocation(233, 27);
						r.Add(new Tuple<string, IExpression>((i!=null?i.Text:null), e));
						DebugLocation(233, 80);
						// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:233:80: ( COMMA i= ID ASSIGN e= expression )*
						try { DebugEnterSubRule(20);
							while (true)
							{
								int alt20=2;
								try { DebugEnterDecision(20, false);
									int LA20_0 = input.LA(1);

									if ((LA20_0==COMMA))
									{
										alt20 = 1;
									}


								} finally { DebugExitDecision(20); }
								switch ( alt20 )
								{
									case 1:
										DebugEnterAlt(1);
										// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:233:81: COMMA i= ID ASSIGN e= expression
									{
										DebugLocation(233, 81);
										Match(input,COMMA,Follow._COMMA_in_field_list1595); 
										DebugLocation(233, 88);
										i=(IToken)Match(input,ID,Follow._ID_in_field_list1599); 
										DebugLocation(233, 92);
										Match(input,ASSIGN,Follow._ASSIGN_in_field_list1601); 
										DebugLocation(233, 100);
										PushFollow(Follow._expression_in_field_list1605);
										e=expression();
										PopFollow();

										DebugLocation(233, 112);
										r.Add(new Tuple<string, IExpression>((i!=null?i.Text:null), e));

									}
										break;

									default:
										goto loop20;
								}
							}

							loop20:
							;

						} finally { DebugExitSubRule(20); }


					}

				}
				catch (RecognitionException re)
				{
					ReportError(re);
					Recover(input,re);
				}
				finally
				{
					TraceOut("field_list", 19);
					LeaveRule("field_list", 19);
					LeaveRule_field_list();
				}
				DebugLocation(234, 0);
			} finally { DebugExitRule(GrammarFileName, "field_list"); }
			return r;

		}
		// $ANTLR end "field_list"

		partial void EnterRule_expression_sequence();
		partial void LeaveRule_expression_sequence();

		// $ANTLR start "expression_sequence"
		// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:236:1: expression_sequence returns [ExpressionList<IExpression> r] : e1= expression ( SEMICOLON e2= expression )* ;
		[GrammarRule("expression_sequence")]
		private ExpressionList<IExpression> expression_sequence()
		{
			EnterRule_expression_sequence();
			EnterRule("expression_sequence", 20);
			TraceIn("expression_sequence", 20);
			ExpressionList<IExpression> r = default(ExpressionList<IExpression>);


			IExpression e1 = default(IExpression);
			IExpression e2 = default(IExpression);


			r = new ExpressionList<IExpression>();

			try { DebugEnterRule(GrammarFileName, "expression_sequence");
				DebugLocation(236, 0);
				try
				{
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:241:3: (e1= expression ( SEMICOLON e2= expression )* )
					DebugEnterAlt(1);
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:241:3: e1= expression ( SEMICOLON e2= expression )*
					{
						DebugLocation(241, 5);
						PushFollow(Follow._expression_in_expression_sequence1628);
						e1=expression();
						PopFollow();

						DebugLocation(241, 16);
						r.Add(e1);
						DebugLocation(241, 29);
						// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:241:29: ( SEMICOLON e2= expression )*
						try { DebugEnterSubRule(21);
							while (true)
							{
								int alt21=2;
								try { DebugEnterDecision(21, false);
									int LA21_0 = input.LA(1);

									if ((LA21_0==SEMICOLON))
									{
										alt21 = 1;
									}


								} finally { DebugExitDecision(21); }
								switch ( alt21 )
								{
									case 1:
										DebugEnterAlt(1);
										// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:241:31: SEMICOLON e2= expression
									{
										DebugLocation(241, 31);
										Match(input,SEMICOLON,Follow._SEMICOLON_in_expression_sequence1633); 
										DebugLocation(241, 43);
										PushFollow(Follow._expression_in_expression_sequence1637);
										e2=expression();
										PopFollow();

										DebugLocation(241, 54);
										r.Add(e2);

									}
										break;

									default:
										goto loop21;
								}
							}

							loop21:
							;

						} finally { DebugExitSubRule(21); }


					}

				}
				catch (RecognitionException re)
				{
					ReportError(re);
					Recover(input,re);
				}
				finally
				{
					TraceOut("expression_sequence", 20);
					LeaveRule("expression_sequence", 20);
					LeaveRule_expression_sequence();
				}
				DebugLocation(242, 0);
			} finally { DebugExitRule(GrammarFileName, "expression_sequence"); }
			return r;

		}
		// $ANTLR end "expression_sequence"

		partial void EnterRule_declaration_list_list();
		partial void LeaveRule_declaration_list_list();

		// $ANTLR start "declaration_list_list"
		// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:244:1: declaration_list_list returns [List<IDeclarationList<IDeclaration>> r] : (e= declaration[r, t] )+ ;
		[GrammarRule("declaration_list_list")]
		private List<IDeclarationList<IDeclaration>> declaration_list_list()
		{
			EnterRule_declaration_list_list();
			EnterRule("declaration_list_list", 21);
			TraceIn("declaration_list_list", 21);
			List<IDeclarationList<IDeclaration>> r = default(List<IDeclarationList<IDeclaration>>);


			DclType e = default(DclType);


			DclType t = DclType.None;
			r = new List<IDeclarationList<IDeclaration>>();

			try { DebugEnterRule(GrammarFileName, "declaration_list_list");
				DebugLocation(244, 0);
				try
				{
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:250:2: ( (e= declaration[r, t] )+ )
					DebugEnterAlt(1);
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:250:2: (e= declaration[r, t] )+
					{
						DebugLocation(250, 2);
						// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:250:2: (e= declaration[r, t] )+
						int cnt22=0;
						try { DebugEnterSubRule(22);
							while (true)
							{
								int alt22=2;
								try { DebugEnterDecision(22, false);
									int LA22_0 = input.LA(1);

									if ((LA22_0==FUNCTION||(LA22_0>=TYPE && LA22_0<=VAR)))
									{
										alt22 = 1;
									}


								} finally { DebugExitDecision(22); }
								switch (alt22)
								{
									case 1:
										DebugEnterAlt(1);
										// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:250:3: e= declaration[r, t]
									{
										DebugLocation(250, 4);
										PushFollow(Follow._declaration_in_declaration_list_list1660);
										e=declaration(r, t);
										PopFollow();

										DebugLocation(250, 23);
										t = e;

									}
										break;

									default:
										if (cnt22 >= 1)
											goto loop22;

										EarlyExitException eee22 = new EarlyExitException( 22, input );
										DebugRecognitionException(eee22);
										throw eee22;
								}
								cnt22++;
							}
							loop22:
							;

						} finally { DebugExitSubRule(22); }


					}

				}
				catch (RecognitionException re)
				{
					ReportError(re);
					Recover(input,re);
				}
				finally
				{
					TraceOut("declaration_list_list", 21);
					LeaveRule("declaration_list_list", 21);
					LeaveRule_declaration_list_list();
				}
				DebugLocation(251, 0);
			} finally { DebugExitRule(GrammarFileName, "declaration_list_list"); }
			return r;

		}
		// $ANTLR end "declaration_list_list"

		partial void EnterRule_declaration();
		partial void LeaveRule_declaration();

		// $ANTLR start "declaration"
		// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:253:1: declaration[List<IDeclarationList<IDeclaration>> r, DclType prec] returns [DclType rt] : (e1= function_declaration |e2= type_declaration |e3= var_declaration );
		[GrammarRule("declaration")]
		private DclType declaration(List<IDeclarationList<IDeclaration>> r, DclType prec)
		{
			EnterRule_declaration();
			EnterRule("declaration", 22);
			TraceIn("declaration", 22);
			DclType rt = default(DclType);


			FunctionDeclaration e1 = default(FunctionDeclaration);
			TypeDeclaration e2 = default(TypeDeclaration);
			VarDeclaration e3 = default(VarDeclaration);


			TypeDeclaration t = null;
			FunctionDeclaration f = null;
			VarDeclaration v = null;

			try { DebugEnterRule(GrammarFileName, "declaration");
				DebugLocation(253, 0);
				try
				{
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:280:3: (e1= function_declaration |e2= type_declaration |e3= var_declaration )
					int alt23=3;
					try { DebugEnterDecision(23, false);
						switch (input.LA(1))
						{
							case FUNCTION:
							{
								alt23 = 1;
							}
								break;
							case TYPE:
							{
								alt23 = 2;
							}
								break;
							case VAR:
							{
								alt23 = 3;
							}
								break;
							default:
							{
								NoViableAltException nvae = new NoViableAltException("", 23, 0, input);
								DebugRecognitionException(nvae);
								throw nvae;
							}
						}

					} finally { DebugExitDecision(23); }
					switch (alt23)
					{
						case 1:
							DebugEnterAlt(1);
							// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:280:3: e1= function_declaration
						{
							DebugLocation(280, 5);
							PushFollow(Follow._function_declaration_in_declaration1692);
							e1=function_declaration();
							PopFollow();

							DebugLocation(280, 27);
							f = e1;

						}
							break;
						case 2:
							DebugEnterAlt(2);
							// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:281:3: e2= type_declaration
						{
							DebugLocation(281, 5);
							PushFollow(Follow._type_declaration_in_declaration1700);
							e2=type_declaration();
							PopFollow();

							DebugLocation(281, 23);
							t = e2;

						}
							break;
						case 3:
							DebugEnterAlt(3);
							// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:282:3: e3= var_declaration
						{
							DebugLocation(282, 5);
							PushFollow(Follow._var_declaration_in_declaration1708);
							e3=var_declaration();
							PopFollow();

							DebugLocation(282, 22);
							v = e3;

						}
							break;

					}

					rt = t != null? DclType.Type : f != null? DclType.Function : v != null? DclType.Var : DclType.None;
				
					switch(rt)
					{
						case DclType.Type:
							if(rt == prec) ((TypeDeclarationList)r[r.Count-1]).Add(t);
							else r.Add(new TypeDeclarationList {t});
							break;
						case DclType.Function:
							if(rt == prec) ((FunctionDeclarationList)r[r.Count-1]).Add(f);
							else r.Add(new FunctionDeclarationList {f});
							break;
						case DclType.Var:
							if(rt == prec) ((DeclarationList<VarDeclaration>)r[r.Count-1]).Add(v);
							else r.Add(new DeclarationList<VarDeclaration> {v});
							break;
					} 

				}
				catch (RecognitionException re)
				{
					ReportError(re);
					Recover(input,re);
				}
				finally
				{
					TraceOut("declaration", 22);
					LeaveRule("declaration", 22);
					LeaveRule_declaration();
				}
				DebugLocation(283, 0);
			} finally { DebugExitRule(GrammarFileName, "declaration"); }
			return rt;

		}
		// $ANTLR end "declaration"

		partial void EnterRule_function_declaration();
		partial void LeaveRule_function_declaration();

		// $ANTLR start "function_declaration"
		// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:285:1: function_declaration returns [FunctionDeclaration r] : FUNCTION i= ID L_PARENT (p= type_fields )? R_PARENT ( COLON t= ID )? EQUAL e= expression ;
		[GrammarRule("function_declaration")]
		private FunctionDeclaration function_declaration()
		{
			EnterRule_function_declaration();
			EnterRule("function_declaration", 23);
			TraceIn("function_declaration", 23);
			FunctionDeclaration r = default(FunctionDeclaration);


			IToken i = default(IToken);
			IToken t = default(IToken);
			IToken FUNCTION19 = default(IToken);
			List<ParameterDeclaration> p = default(List<ParameterDeclaration>);
			IExpression e = default(IExpression);

			string type = null;
			try { DebugEnterRule(GrammarFileName, "function_declaration");
				DebugLocation(285, 0);
				try
				{
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:287:3: ( FUNCTION i= ID L_PARENT (p= type_fields )? R_PARENT ( COLON t= ID )? EQUAL e= expression )
					DebugEnterAlt(1);
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:287:3: FUNCTION i= ID L_PARENT (p= type_fields )? R_PARENT ( COLON t= ID )? EQUAL e= expression
					{
						DebugLocation(287, 3);
						FUNCTION19=(IToken)Match(input,FUNCTION,Follow._FUNCTION_in_function_declaration1730); 
						DebugLocation(287, 13);
						i=(IToken)Match(input,ID,Follow._ID_in_function_declaration1734); 
						DebugLocation(287, 17);
						Match(input,L_PARENT,Follow._L_PARENT_in_function_declaration1736); 
						DebugLocation(287, 27);
						// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:287:27: (p= type_fields )?
						int alt24=2;
						try { DebugEnterSubRule(24);
							try { DebugEnterDecision(24, false);
								int LA24_0 = input.LA(1);

								if ((LA24_0==ID))
								{
									alt24 = 1;
								}
							} finally { DebugExitDecision(24); }
							switch (alt24)
							{
								case 1:
									DebugEnterAlt(1);
									// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:287:27: p= type_fields
								{
									DebugLocation(287, 27);
									PushFollow(Follow._type_fields_in_function_declaration1740);
									p=type_fields();
									PopFollow();


								}
									break;

							}
						} finally { DebugExitSubRule(24); }

						DebugLocation(287, 41);
						Match(input,R_PARENT,Follow._R_PARENT_in_function_declaration1743); 
						DebugLocation(287, 50);
						// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:287:50: ( COLON t= ID )?
						int alt25=2;
						try { DebugEnterSubRule(25);
							try { DebugEnterDecision(25, false);
								int LA25_0 = input.LA(1);

								if ((LA25_0==COLON))
								{
									alt25 = 1;
								}
							} finally { DebugExitDecision(25); }
							switch (alt25)
							{
								case 1:
									DebugEnterAlt(1);
									// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:287:51: COLON t= ID
								{
									DebugLocation(287, 51);
									Match(input,COLON,Follow._COLON_in_function_declaration1746); 
									DebugLocation(287, 58);
									t=(IToken)Match(input,ID,Follow._ID_in_function_declaration1750); 
									DebugLocation(287, 62);
									type = (t!=null?t.Text:null);

								}
									break;

							}
						} finally { DebugExitSubRule(25); }

						DebugLocation(287, 82);
						Match(input,EQUAL,Follow._EQUAL_in_function_declaration1756); 
						DebugLocation(287, 89);
						PushFollow(Follow._expression_in_function_declaration1760);
						e=expression();
						PopFollow();

						DebugLocation(287, 100);
						r = new FunctionDeclaration{line = FUNCTION19.Line, column = FUNCTION19.CharPositionInLine, Parameters = p ?? new List<ParameterDeclaration>(), Return = type, FunctionName = (i!=null?i.Text:null), Body = e};

					}

				}
				catch (RecognitionException re)
				{
					ReportError(re);
					Recover(input,re);
				}
				finally
				{
					TraceOut("function_declaration", 23);
					LeaveRule("function_declaration", 23);
					LeaveRule_function_declaration();
				}
				DebugLocation(288, 0);
			} finally { DebugExitRule(GrammarFileName, "function_declaration"); }
			return r;

		}
		// $ANTLR end "function_declaration"

		partial void EnterRule_var_declaration();
		partial void LeaveRule_var_declaration();

		// $ANTLR start "var_declaration"
		// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:290:1: var_declaration returns [VarDeclaration r] : VAR i= ID ( ASSIGN e= expression | COLON ti= ID ASSIGN e= expression ) ;
		[GrammarRule("var_declaration")]
		private VarDeclaration var_declaration()
		{
			EnterRule_var_declaration();
			EnterRule("var_declaration", 24);
			TraceIn("var_declaration", 24);
			VarDeclaration r = default(VarDeclaration);


			IToken i = default(IToken);
			IToken ti = default(IToken);
			IToken VAR20 = default(IToken);
			IExpression e = default(IExpression);

			try { DebugEnterRule(GrammarFileName, "var_declaration");
				DebugLocation(290, 0);
				try
				{
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:291:3: ( VAR i= ID ( ASSIGN e= expression | COLON ti= ID ASSIGN e= expression ) )
					DebugEnterAlt(1);
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:291:3: VAR i= ID ( ASSIGN e= expression | COLON ti= ID ASSIGN e= expression )
					{
						DebugLocation(291, 3);
						VAR20=(IToken)Match(input,VAR,Follow._VAR_in_var_declaration1774); 
						DebugLocation(291, 8);
						i=(IToken)Match(input,ID,Follow._ID_in_var_declaration1778); 
						DebugLocation(291, 12);
						// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:291:12: ( ASSIGN e= expression | COLON ti= ID ASSIGN e= expression )
						int alt26=2;
						try { DebugEnterSubRule(26);
							try { DebugEnterDecision(26, false);
								int LA26_0 = input.LA(1);

								if ((LA26_0==ASSIGN))
								{
									alt26 = 1;
								}
								else if ((LA26_0==COLON))
								{
									alt26 = 2;
								}
								else
								{
									NoViableAltException nvae = new NoViableAltException("", 26, 0, input);
									DebugRecognitionException(nvae);
									throw nvae;
								}
							} finally { DebugExitDecision(26); }
							switch (alt26)
							{
								case 1:
									DebugEnterAlt(1);
									// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:291:13: ASSIGN e= expression
								{
									DebugLocation(291, 13);
									Match(input,ASSIGN,Follow._ASSIGN_in_var_declaration1781); 
									DebugLocation(291, 21);
									PushFollow(Follow._expression_in_var_declaration1785);
									e=expression();
									PopFollow();

									DebugLocation(291, 33);
									r = new VarDeclaration {line = VAR20.Line, column = VAR20.CharPositionInLine, HolderName = (i!=null?i.Text:null), Init = e};

								}
									break;
								case 2:
									DebugEnterAlt(2);
									// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:292:4: COLON ti= ID ASSIGN e= expression
								{
									DebugLocation(292, 4);
									Match(input,COLON,Follow._COLON_in_var_declaration1792); 
									DebugLocation(292, 12);
									ti=(IToken)Match(input,ID,Follow._ID_in_var_declaration1796); 
									DebugLocation(292, 16);
									Match(input,ASSIGN,Follow._ASSIGN_in_var_declaration1798); 
									DebugLocation(292, 24);
									PushFollow(Follow._expression_in_var_declaration1802);
									e=expression();
									PopFollow();

									DebugLocation(292, 36);
									r = new VarDeclaration {line = VAR20.Line, column = VAR20.CharPositionInLine, HolderName = (i!=null?i.Text:null), HolderType = (ti!=null?ti.Text:null), Init = e};

								}
									break;

							}
						} finally { DebugExitSubRule(26); }


					}

				}
				catch (RecognitionException re)
				{
					ReportError(re);
					Recover(input,re);
				}
				finally
				{
					TraceOut("var_declaration", 24);
					LeaveRule("var_declaration", 24);
					LeaveRule_var_declaration();
				}
				DebugLocation(293, 0);
			} finally { DebugExitRule(GrammarFileName, "var_declaration"); }
			return r;

		}
		// $ANTLR end "var_declaration"

		partial void EnterRule_type_declaration();
		partial void LeaveRule_type_declaration();

		// $ANTLR start "type_declaration"
		// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:295:1: type_declaration returns [TypeDeclaration r] : TYPE i= ID EQUAL t1= type ;
		[GrammarRule("type_declaration")]
		private TypeDeclaration type_declaration()
		{
			EnterRule_type_declaration();
			EnterRule("type_declaration", 25);
			TraceIn("type_declaration", 25);
			TypeDeclaration r = default(TypeDeclaration);


			IToken i = default(IToken);
			IToken TYPE21 = default(IToken);
			TypeDeclaration t1 = default(TypeDeclaration);

			try { DebugEnterRule(GrammarFileName, "type_declaration");
				DebugLocation(295, 0);
				try
				{
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:296:3: ( TYPE i= ID EQUAL t1= type )
					DebugEnterAlt(1);
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:296:3: TYPE i= ID EQUAL t1= type
					{
						DebugLocation(296, 3);
						TYPE21=(IToken)Match(input,TYPE,Follow._TYPE_in_type_declaration1820); 
						DebugLocation(296, 9);
						i=(IToken)Match(input,ID,Follow._ID_in_type_declaration1824); 
						DebugLocation(296, 13);
						Match(input,EQUAL,Follow._EQUAL_in_type_declaration1826); 
						DebugLocation(296, 21);
						PushFollow(Follow._type_in_type_declaration1831);
						t1=type();
						PopFollow();

						DebugLocation(296, 28);
						t1.TypeName = (i!=null?i.Text:null); t1.line = (TYPE21!=null?TYPE21.Line:0); t1.column = TYPE21.CharPositionInLine; r = t1;

					}

				}
				catch (RecognitionException re)
				{
					ReportError(re);
					Recover(input,re);
				}
				finally
				{
					TraceOut("type_declaration", 25);
					LeaveRule("type_declaration", 25);
					LeaveRule_type_declaration();
				}
				DebugLocation(297, 0);
			} finally { DebugExitRule(GrammarFileName, "type_declaration"); }
			return r;

		}
		// $ANTLR end "type_declaration"

		partial void EnterRule_type();
		partial void LeaveRule_type();

		// $ANTLR start "type"
		// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:299:1: type returns [TypeDeclaration r] : ( ARRAY OF i= ID |i= ID |l= L_KEY (t= type_creation_fields )? R_KEY );
		[GrammarRule("type")]
		private TypeDeclaration type()
		{
			EnterRule_type();
			EnterRule("type", 26);
			TraceIn("type", 26);
			TypeDeclaration r = default(TypeDeclaration);


			IToken i = default(IToken);
			IToken l = default(IToken);
			List<Tuple<string, string>> t = default(List<Tuple<string, string>>);

			try { DebugEnterRule(GrammarFileName, "type");
				DebugLocation(299, 0);
				try
				{
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:300:3: ( ARRAY OF i= ID |i= ID |l= L_KEY (t= type_creation_fields )? R_KEY )
					int alt28=3;
					try { DebugEnterDecision(28, false);
						switch (input.LA(1))
						{
							case ARRAY:
							{
								alt28 = 1;
							}
								break;
							case ID:
							{
								alt28 = 2;
							}
								break;
							case L_KEY:
							{
								alt28 = 3;
							}
								break;
							default:
							{
								NoViableAltException nvae = new NoViableAltException("", 28, 0, input);
								DebugRecognitionException(nvae);
								throw nvae;
							}
						}

					} finally { DebugExitDecision(28); }
					switch (alt28)
					{
						case 1:
							DebugEnterAlt(1);
							// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:300:3: ARRAY OF i= ID
						{
							DebugLocation(300, 3);
							Match(input,ARRAY,Follow._ARRAY_in_type1846); 
							DebugLocation(300, 9);
							Match(input,OF,Follow._OF_in_type1848); 
							DebugLocation(300, 13);
							i=(IToken)Match(input,ID,Follow._ID_in_type1852); 
							DebugLocation(300, 17);
							r = new ArrayDeclaration{ArrayOf = (i!=null?i.Text:null)};

						}
							break;
						case 2:
							DebugEnterAlt(2);
							// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:301:3: i= ID
						{
							DebugLocation(301, 4);
							i=(IToken)Match(input,ID,Follow._ID_in_type1860); 
							DebugLocation(301, 8);
							r = new AliasDeclaration{AliasOf = (i!=null?i.Text:null)};

						}
							break;
						case 3:
							DebugEnterAlt(3);
							// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:302:3: l= L_KEY (t= type_creation_fields )? R_KEY
						{
							DebugLocation(302, 4);
							l=(IToken)Match(input,L_KEY,Follow._L_KEY_in_type1868); 
							DebugLocation(302, 12);
							// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:302:12: (t= type_creation_fields )?
							int alt27=2;
							try { DebugEnterSubRule(27);
								try { DebugEnterDecision(27, false);
									int LA27_0 = input.LA(1);

									if ((LA27_0==ID))
									{
										alt27 = 1;
									}
								} finally { DebugExitDecision(27); }
								switch (alt27)
								{
									case 1:
										DebugEnterAlt(1);
										// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:302:12: t= type_creation_fields
									{
										DebugLocation(302, 12);
										PushFollow(Follow._type_creation_fields_in_type1872);
										t=type_creation_fields();
										PopFollow();


									}
										break;

								}
							} finally { DebugExitSubRule(27); }

							DebugLocation(302, 35);
							Match(input,R_KEY,Follow._R_KEY_in_type1875); 
							DebugLocation(302, 41);
							r = new RecordDeclaration{Members = t ?? new List<Tuple<string, string>>()};

						}
							break;

					}
				}
				catch (RecognitionException re)
				{
					ReportError(re);
					Recover(input,re);
				}
				finally
				{
					TraceOut("type", 26);
					LeaveRule("type", 26);
					LeaveRule_type();
				}
				DebugLocation(303, 0);
			} finally { DebugExitRule(GrammarFileName, "type"); }
			return r;

		}
		// $ANTLR end "type"

		partial void EnterRule_type_creation_fields();
		partial void LeaveRule_type_creation_fields();

		// $ANTLR start "type_creation_fields"
		// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:305:1: type_creation_fields returns [List<Tuple<string, string>> r] : i= ID COLON ti= ID (i= ID COLON ti= ID )* ;
		[GrammarRule("type_creation_fields")]
		private List<Tuple<string, string>> type_creation_fields()
		{
			EnterRule_type_creation_fields();
			EnterRule("type_creation_fields", 27);
			TraceIn("type_creation_fields", 27);
			List<Tuple<string, string>> r = default(List<Tuple<string, string>>);


			IToken i = default(IToken);
			IToken ti = default(IToken);


			r = new List<Tuple<string, string>>();

			try { DebugEnterRule(GrammarFileName, "type_creation_fields");
				DebugLocation(305, 0);
				try
				{
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:310:3: (i= ID COLON ti= ID (i= ID COLON ti= ID )* )
					DebugEnterAlt(1);
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:310:3: i= ID COLON ti= ID (i= ID COLON ti= ID )*
					{
						DebugLocation(310, 4);
						i=(IToken)Match(input,ID,Follow._ID_in_type_creation_fields1897); 
						DebugLocation(310, 8);
						Match(input,COLON,Follow._COLON_in_type_creation_fields1899); 
						DebugLocation(310, 16);
						ti=(IToken)Match(input,ID,Follow._ID_in_type_creation_fields1903); 
						DebugLocation(310, 20);
						r.Add(new Tuple<string, string>((i!=null?i.Text:null),(ti!=null?ti.Text:null)));
						DebugLocation(310, 74);
						// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:310:74: (i= ID COLON ti= ID )*
						try { DebugEnterSubRule(29);
							while (true)
							{
								int alt29=2;
								try { DebugEnterDecision(29, false);
									int LA29_0 = input.LA(1);

									if ((LA29_0==ID))
									{
										alt29 = 1;
									}


								} finally { DebugExitDecision(29); }
								switch ( alt29 )
								{
									case 1:
										DebugEnterAlt(1);
										// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:310:75: i= ID COLON ti= ID
									{
										DebugLocation(310, 76);
										i=(IToken)Match(input,ID,Follow._ID_in_type_creation_fields1910); 
										DebugLocation(310, 80);
										Match(input,COLON,Follow._COLON_in_type_creation_fields1912); 
										DebugLocation(310, 88);
										ti=(IToken)Match(input,ID,Follow._ID_in_type_creation_fields1916); 
										DebugLocation(310, 92);
										r.Add(new Tuple<string, string>((i!=null?i.Text:null),(ti!=null?ti.Text:null)));

									}
										break;

									default:
										goto loop29;
								}
							}

							loop29:
							;

						} finally { DebugExitSubRule(29); }


					}

				}
				catch (RecognitionException re)
				{
					ReportError(re);
					Recover(input,re);
				}
				finally
				{
					TraceOut("type_creation_fields", 27);
					LeaveRule("type_creation_fields", 27);
					LeaveRule_type_creation_fields();
				}
				DebugLocation(311, 0);
			} finally { DebugExitRule(GrammarFileName, "type_creation_fields"); }
			return r;

		}
		// $ANTLR end "type_creation_fields"

		partial void EnterRule_type_fields();
		partial void LeaveRule_type_fields();

		// $ANTLR start "type_fields"
		// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:313:1: type_fields returns [List<ParameterDeclaration> r] : t= type_field ( COMMA t= type_field )* ;
		[GrammarRule("type_fields")]
		private List<ParameterDeclaration> type_fields()
		{
			EnterRule_type_fields();
			EnterRule("type_fields", 28);
			TraceIn("type_fields", 28);
			List<ParameterDeclaration> r = default(List<ParameterDeclaration>);


			ParameterDeclaration t = default(ParameterDeclaration);


			r = new List<ParameterDeclaration>();
			int c = 0;

			try { DebugEnterRule(GrammarFileName, "type_fields");
				DebugLocation(313, 0);
				try
				{
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:319:3: (t= type_field ( COMMA t= type_field )* )
					DebugEnterAlt(1);
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:319:3: t= type_field ( COMMA t= type_field )*
					{
						DebugLocation(319, 4);
						PushFollow(Follow._type_field_in_type_fields1939);
						t=type_field();
						PopFollow();

						DebugLocation(319, 15);
						if (t != null)t.Position = c; r.Add(t); c++;
						DebugLocation(319, 62);
						// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:319:62: ( COMMA t= type_field )*
						try { DebugEnterSubRule(30);
							while (true)
							{
								int alt30=2;
								try { DebugEnterDecision(30, false);
									int LA30_0 = input.LA(1);

									if ((LA30_0==COMMA))
									{
										alt30 = 1;
									}


								} finally { DebugExitDecision(30); }
								switch ( alt30 )
								{
									case 1:
										DebugEnterAlt(1);
										// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:319:63: COMMA t= type_field
									{
										DebugLocation(319, 63);
										Match(input,COMMA,Follow._COMMA_in_type_fields1943); 
										DebugLocation(319, 70);
										PushFollow(Follow._type_field_in_type_fields1947);
										t=type_field();
										PopFollow();

										DebugLocation(319, 81);
										if (t != null)t.Position = c; r.Add(t); c++;

									}
										break;

									default:
										goto loop30;
								}
							}

							loop30:
							;

						} finally { DebugExitSubRule(30); }


					}

				}
				catch (RecognitionException re)
				{
					ReportError(re);
					Recover(input,re);
				}
				finally
				{
					TraceOut("type_fields", 28);
					LeaveRule("type_fields", 28);
					LeaveRule_type_fields();
				}
				DebugLocation(320, 0);
			} finally { DebugExitRule(GrammarFileName, "type_fields"); }
			return r;

		}
		// $ANTLR end "type_fields"

		partial void EnterRule_type_field();
		partial void LeaveRule_type_field();

		// $ANTLR start "type_field"
		// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:322:1: type_field returns [ParameterDeclaration r] : i= ID COLON t= ID ;
		[GrammarRule("type_field")]
		private ParameterDeclaration type_field()
		{
			EnterRule_type_field();
			EnterRule("type_field", 29);
			TraceIn("type_field", 29);
			ParameterDeclaration r = default(ParameterDeclaration);


			IToken i = default(IToken);
			IToken t = default(IToken);

			try { DebugEnterRule(GrammarFileName, "type_field");
				DebugLocation(322, 0);
				try
				{
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:323:3: (i= ID COLON t= ID )
					DebugEnterAlt(1);
					// E:\\Jesus\\Documentos\\C.Computacion\\Proyectos\\Dockyard\\TigerComp\\TigerCs\\Parser\\Tiger\\Tigrammar.g:323:3: i= ID COLON t= ID
					{
						DebugLocation(323, 4);
						i=(IToken)Match(input,ID,Follow._ID_in_type_field1964); 
						DebugLocation(323, 8);
						Match(input,COLON,Follow._COLON_in_type_field1966); 
						DebugLocation(323, 15);
						t=(IToken)Match(input,ID,Follow._ID_in_type_field1970); 
						DebugLocation(323, 19);
						r = new ParameterDeclaration{line = i.Line, column = i.CharPositionInLine, HolderName = (i!=null?i.Text:null), HolderType = (t!=null?t.Text:null)};

					}

				}
				catch (RecognitionException re)
				{
					ReportError(re);
					Recover(input,re);
				}
				finally
				{
					TraceOut("type_field", 29);
					LeaveRule("type_field", 29);
					LeaveRule_type_field();
				}
				DebugLocation(324, 0);
			} finally { DebugExitRule(GrammarFileName, "type_field"); }
			return r;

		}
		// $ANTLR end "type_field"
		#endregion Rules


		#region Follow sets
		private static class Follow
		{
			public static readonly BitSet _expression_in_program826 = new BitSet(new ulong[]{0x0UL});
			public static readonly BitSet _EOF_in_program830 = new BitSet(new ulong[]{0x2UL});
			public static readonly BitSet _or_expression_in_expression845 = new BitSet(new ulong[]{0x40000000002UL});
			public static readonly BitSet _or_expression_rest_in_expression852 = new BitSet(new ulong[]{0x2UL});
			public static readonly BitSet _and_expression_in_or_expression872 = new BitSet(new ulong[]{0x12UL});
			public static readonly BitSet _and_expression_rest_in_or_expression879 = new BitSet(new ulong[]{0x2UL});
			public static readonly BitSet _OR_in_or_expression_rest899 = new BitSet(new ulong[]{0x2100B06C400080UL});
			public static readonly BitSet _expression_in_or_expression_rest903 = new BitSet(new ulong[]{0x2UL});
			public static readonly BitSet _aritmetic_expression_in_and_expression920 = new BitSet(new ulong[]{0x10303100002UL});
			public static readonly BitSet _relational_expression_in_and_expression927 = new BitSet(new ulong[]{0x2UL});
			public static readonly BitSet _AND_in_and_expression_rest947 = new BitSet(new ulong[]{0x2100B06C400080UL});
			public static readonly BitSet _or_expression_in_and_expression_rest951 = new BitSet(new ulong[]{0x2UL});
			public static readonly BitSet _EQUAL_in_relational_expression968 = new BitSet(new ulong[]{0x2100B06C400080UL});
			public static readonly BitSet _aritmetic_expression_in_relational_expression972 = new BitSet(new ulong[]{0x2UL});
			public static readonly BitSet _NOT_EQUAL_in_relational_expression978 = new BitSet(new ulong[]{0x2100B06C400080UL});
			public static readonly BitSet _aritmetic_expression_in_relational_expression982 = new BitSet(new ulong[]{0x2UL});
			public static readonly BitSet _GTHAN_in_relational_expression988 = new BitSet(new ulong[]{0x2100B06C400080UL});
			public static readonly BitSet _aritmetic_expression_in_relational_expression992 = new BitSet(new ulong[]{0x2UL});
			public static readonly BitSet _LTHAN_in_relational_expression998 = new BitSet(new ulong[]{0x2100B06C400080UL});
			public static readonly BitSet _aritmetic_expression_in_relational_expression1002 = new BitSet(new ulong[]{0x2UL});
			public static readonly BitSet _GTHAN_EQUAL_in_relational_expression1008 = new BitSet(new ulong[]{0x2100B06C400080UL});
			public static readonly BitSet _aritmetic_expression_in_relational_expression1012 = new BitSet(new ulong[]{0x2UL});
			public static readonly BitSet _LTHAN_EQUAL_in_relational_expression1018 = new BitSet(new ulong[]{0x2100B06C400080UL});
			public static readonly BitSet _aritmetic_expression_in_relational_expression1022 = new BitSet(new ulong[]{0x2UL});
			public static readonly BitSet _term_in_aritmetic_expression1038 = new BitSet(new ulong[]{0x82000000002UL});
			public static readonly BitSet _aritmetic_expression_rest_in_aritmetic_expression1045 = new BitSet(new ulong[]{0x2UL});
			public static readonly BitSet _set_in_aritmetic_expression_rest1068 = new BitSet(new ulong[]{0x2100B06C400080UL});
			public static readonly BitSet _term_in_aritmetic_expression_rest1079 = new BitSet(new ulong[]{0x82000000002UL});
			public static readonly BitSet _aritmetic_expression_rest_in_aritmetic_expression_rest1088 = new BitSet(new ulong[]{0x2UL});
			public static readonly BitSet _factor_in_term1107 = new BitSet(new ulong[]{0x4000004002UL});
			public static readonly BitSet _term_rest_in_term1114 = new BitSet(new ulong[]{0x2UL});
			public static readonly BitSet _set_in_term_rest1136 = new BitSet(new ulong[]{0x2100B06C400080UL});
			public static readonly BitSet _factor_in_term_rest1146 = new BitSet(new ulong[]{0x4000004002UL});
			public static readonly BitSet _term_rest_in_term_rest1154 = new BitSet(new ulong[]{0x2UL});
			public static readonly BitSet _STRING_in_factor1174 = new BitSet(new ulong[]{0x2UL});
			public static readonly BitSet _INT_in_factor1183 = new BitSet(new ulong[]{0x2UL});
			public static readonly BitSet _NIL_in_factor1191 = new BitSet(new ulong[]{0x2UL});
			public static readonly BitSet _MINUS_in_factor1197 = new BitSet(new ulong[]{0x2100B06C400080UL});
			public static readonly BitSet _expression_in_factor1201 = new BitSet(new ulong[]{0x2UL});
			public static readonly BitSet _L_PARENT_in_factor1207 = new BitSet(new ulong[]{0x2140B06C400080UL});
			public static readonly BitSet _expression_sequence_in_factor1212 = new BitSet(new ulong[]{0x400000000000UL});
			public static readonly BitSet _R_PARENT_in_factor1218 = new BitSet(new ulong[]{0x2UL});
			public static readonly BitSet _IF_in_factor1222 = new BitSet(new ulong[]{0x2100B06C400080UL});
			public static readonly BitSet _expression_in_factor1226 = new BitSet(new ulong[]{0x2000000000000UL});
			public static readonly BitSet _THEN_in_factor1228 = new BitSet(new ulong[]{0x2100B06C400080UL});
			public static readonly BitSet _expression_in_factor1232 = new BitSet(new ulong[]{0x40002UL});
			public static readonly BitSet _ELSE_in_factor1237 = new BitSet(new ulong[]{0x2100B06C400080UL});
			public static readonly BitSet _expression_in_factor1241 = new BitSet(new ulong[]{0x2UL});
			public static readonly BitSet _WHILE_in_factor1249 = new BitSet(new ulong[]{0x2100B06C400080UL});
			public static readonly BitSet _expression_in_factor1253 = new BitSet(new ulong[]{0x8000UL});
			public static readonly BitSet _DO_in_factor1255 = new BitSet(new ulong[]{0x2100B06C400080UL});
			public static readonly BitSet _expression_in_factor1259 = new BitSet(new ulong[]{0x2UL});
			public static readonly BitSet _FOR_in_factor1265 = new BitSet(new ulong[]{0x4000000UL});
			public static readonly BitSet _ID_in_factor1269 = new BitSet(new ulong[]{0x40UL});
			public static readonly BitSet _ASSIGN_in_factor1271 = new BitSet(new ulong[]{0x2100B06C400080UL});
			public static readonly BitSet _expression_in_factor1275 = new BitSet(new ulong[]{0x4000000000000UL});
			public static readonly BitSet _TO_in_factor1277 = new BitSet(new ulong[]{0x2100B06C400080UL});
			public static readonly BitSet _expression_in_factor1281 = new BitSet(new ulong[]{0x8000UL});
			public static readonly BitSet _DO_in_factor1283 = new BitSet(new ulong[]{0x2100B06C400080UL});
			public static readonly BitSet _expression_in_factor1287 = new BitSet(new ulong[]{0x2UL});
			public static readonly BitSet _BREAK_in_factor1293 = new BitSet(new ulong[]{0x2UL});
			public static readonly BitSet _LET_in_factor1299 = new BitSet(new ulong[]{0x18000000800000UL});
			public static readonly BitSet _declaration_list_list_in_factor1303 = new BitSet(new ulong[]{0x10000000UL});
			public static readonly BitSet _IN_in_factor1305 = new BitSet(new ulong[]{0x2100B06C400080UL});
			public static readonly BitSet _expression_in_factor1309 = new BitSet(new ulong[]{0x80000UL});
			public static readonly BitSet _END_in_factor1311 = new BitSet(new ulong[]{0x2UL});
			public static readonly BitSet _lvalue_head_in_factor1319 = new BitSet(new ulong[]{0x2UL});
			public static readonly BitSet _ID_in_lvalue_head1340 = new BitSet(new ulong[]{0x1C00010002UL});
			public static readonly BitSet _invoke_in_lvalue_head1345 = new BitSet(new ulong[]{0x2UL});
			public static readonly BitSet _L_BRACKETS_in_lvalue_head1355 = new BitSet(new ulong[]{0x2100B06C400080UL});
			public static readonly BitSet _expression_in_lvalue_head1359 = new BitSet(new ulong[]{0x100000000000UL});
			public static readonly BitSet _R_BRACKETS_in_lvalue_head1361 = new BitSet(new ulong[]{0x20400010040UL});
			public static readonly BitSet _array_in_lvalue_head1365 = new BitSet(new ulong[]{0x2UL});
			public static readonly BitSet _DOT_in_lvalue_head1374 = new BitSet(new ulong[]{0x4000000UL});
			public static readonly BitSet _ID_in_lvalue_head1378 = new BitSet(new ulong[]{0x400010040UL});
			public static readonly BitSet _dot_in_lvalue_head1382 = new BitSet(new ulong[]{0x2UL});
			public static readonly BitSet _L_PARENT_in_invoke1403 = new BitSet(new ulong[]{0x2140B06C400080UL});
			public static readonly BitSet _arg_list_in_invoke1407 = new BitSet(new ulong[]{0x400000000000UL});
			public static readonly BitSet _R_PARENT_in_invoke1410 = new BitSet(new ulong[]{0x2UL});
			public static readonly BitSet _L_KEY_in_invoke1416 = new BitSet(new ulong[]{0x200004000000UL});
			public static readonly BitSet _field_list_in_invoke1420 = new BitSet(new ulong[]{0x200000000000UL});
			public static readonly BitSet _R_KEY_in_invoke1423 = new BitSet(new ulong[]{0x2UL});
			public static readonly BitSet _OF_in_array1440 = new BitSet(new ulong[]{0x2100B06C400080UL});
			public static readonly BitSet _expression_in_array1444 = new BitSet(new ulong[]{0x2UL});
			public static readonly BitSet _lvalue_in_array1452 = new BitSet(new ulong[]{0x2UL});
			public static readonly BitSet _lvalue_in_dot1472 = new BitSet(new ulong[]{0x2UL});
			public static readonly BitSet _DOT_in_lvalue1496 = new BitSet(new ulong[]{0x4000000UL});
			public static readonly BitSet _ID_in_lvalue1500 = new BitSet(new ulong[]{0x400010042UL});
			public static readonly BitSet _L_BRACKETS_in_lvalue1508 = new BitSet(new ulong[]{0x2100B06C400080UL});
			public static readonly BitSet _expression_in_lvalue1512 = new BitSet(new ulong[]{0x100000000000UL});
			public static readonly BitSet _R_BRACKETS_in_lvalue1514 = new BitSet(new ulong[]{0x400010042UL});
			public static readonly BitSet _ASSIGN_in_lvalue1524 = new BitSet(new ulong[]{0x2100B06C400080UL});
			public static readonly BitSet _expression_in_lvalue1528 = new BitSet(new ulong[]{0x2UL});
			public static readonly BitSet _expression_in_arg_list1552 = new BitSet(new ulong[]{0x202UL});
			public static readonly BitSet _COMMA_in_arg_list1557 = new BitSet(new ulong[]{0x2100B06C400080UL});
			public static readonly BitSet _expression_in_arg_list1562 = new BitSet(new ulong[]{0x202UL});
			public static readonly BitSet _ID_in_field_list1585 = new BitSet(new ulong[]{0x40UL});
			public static readonly BitSet _ASSIGN_in_field_list1587 = new BitSet(new ulong[]{0x2100B06C400080UL});
			public static readonly BitSet _expression_in_field_list1591 = new BitSet(new ulong[]{0x202UL});
			public static readonly BitSet _COMMA_in_field_list1595 = new BitSet(new ulong[]{0x4000000UL});
			public static readonly BitSet _ID_in_field_list1599 = new BitSet(new ulong[]{0x40UL});
			public static readonly BitSet _ASSIGN_in_field_list1601 = new BitSet(new ulong[]{0x2100B06C400080UL});
			public static readonly BitSet _expression_in_field_list1605 = new BitSet(new ulong[]{0x202UL});
			public static readonly BitSet _expression_in_expression_sequence1628 = new BitSet(new ulong[]{0x800000000002UL});
			public static readonly BitSet _SEMICOLON_in_expression_sequence1633 = new BitSet(new ulong[]{0x2100B06C400080UL});
			public static readonly BitSet _expression_in_expression_sequence1637 = new BitSet(new ulong[]{0x800000000002UL});
			public static readonly BitSet _declaration_in_declaration_list_list1660 = new BitSet(new ulong[]{0x18000000800002UL});
			public static readonly BitSet _function_declaration_in_declaration1692 = new BitSet(new ulong[]{0x2UL});
			public static readonly BitSet _type_declaration_in_declaration1700 = new BitSet(new ulong[]{0x2UL});
			public static readonly BitSet _var_declaration_in_declaration1708 = new BitSet(new ulong[]{0x2UL});
			public static readonly BitSet _FUNCTION_in_function_declaration1730 = new BitSet(new ulong[]{0x4000000UL});
			public static readonly BitSet _ID_in_function_declaration1734 = new BitSet(new ulong[]{0x1000000000UL});
			public static readonly BitSet _L_PARENT_in_function_declaration1736 = new BitSet(new ulong[]{0x400004000000UL});
			public static readonly BitSet _type_fields_in_function_declaration1740 = new BitSet(new ulong[]{0x400000000000UL});
			public static readonly BitSet _R_PARENT_in_function_declaration1743 = new BitSet(new ulong[]{0x100100UL});
			public static readonly BitSet _COLON_in_function_declaration1746 = new BitSet(new ulong[]{0x4000000UL});
			public static readonly BitSet _ID_in_function_declaration1750 = new BitSet(new ulong[]{0x100000UL});
			public static readonly BitSet _EQUAL_in_function_declaration1756 = new BitSet(new ulong[]{0x2100B06C400080UL});
			public static readonly BitSet _expression_in_function_declaration1760 = new BitSet(new ulong[]{0x2UL});
			public static readonly BitSet _VAR_in_var_declaration1774 = new BitSet(new ulong[]{0x4000000UL});
			public static readonly BitSet _ID_in_var_declaration1778 = new BitSet(new ulong[]{0x140UL});
			public static readonly BitSet _ASSIGN_in_var_declaration1781 = new BitSet(new ulong[]{0x2100B06C400080UL});
			public static readonly BitSet _expression_in_var_declaration1785 = new BitSet(new ulong[]{0x2UL});
			public static readonly BitSet _COLON_in_var_declaration1792 = new BitSet(new ulong[]{0x4000000UL});
			public static readonly BitSet _ID_in_var_declaration1796 = new BitSet(new ulong[]{0x40UL});
			public static readonly BitSet _ASSIGN_in_var_declaration1798 = new BitSet(new ulong[]{0x2100B06C400080UL});
			public static readonly BitSet _expression_in_var_declaration1802 = new BitSet(new ulong[]{0x2UL});
			public static readonly BitSet _TYPE_in_type_declaration1820 = new BitSet(new ulong[]{0x4000000UL});
			public static readonly BitSet _ID_in_type_declaration1824 = new BitSet(new ulong[]{0x100000UL});
			public static readonly BitSet _EQUAL_in_type_declaration1826 = new BitSet(new ulong[]{0x804000020UL});
			public static readonly BitSet _type_in_type_declaration1831 = new BitSet(new ulong[]{0x2UL});
			public static readonly BitSet _ARRAY_in_type1846 = new BitSet(new ulong[]{0x20000000000UL});
			public static readonly BitSet _OF_in_type1848 = new BitSet(new ulong[]{0x4000000UL});
			public static readonly BitSet _ID_in_type1852 = new BitSet(new ulong[]{0x2UL});
			public static readonly BitSet _ID_in_type1860 = new BitSet(new ulong[]{0x2UL});
			public static readonly BitSet _L_KEY_in_type1868 = new BitSet(new ulong[]{0x200004000000UL});
			public static readonly BitSet _type_creation_fields_in_type1872 = new BitSet(new ulong[]{0x200000000000UL});
			public static readonly BitSet _R_KEY_in_type1875 = new BitSet(new ulong[]{0x2UL});
			public static readonly BitSet _ID_in_type_creation_fields1897 = new BitSet(new ulong[]{0x100UL});
			public static readonly BitSet _COLON_in_type_creation_fields1899 = new BitSet(new ulong[]{0x4000000UL});
			public static readonly BitSet _ID_in_type_creation_fields1903 = new BitSet(new ulong[]{0x4000002UL});
			public static readonly BitSet _ID_in_type_creation_fields1910 = new BitSet(new ulong[]{0x100UL});
			public static readonly BitSet _COLON_in_type_creation_fields1912 = new BitSet(new ulong[]{0x4000000UL});
			public static readonly BitSet _ID_in_type_creation_fields1916 = new BitSet(new ulong[]{0x4000002UL});
			public static readonly BitSet _type_field_in_type_fields1939 = new BitSet(new ulong[]{0x202UL});
			public static readonly BitSet _COMMA_in_type_fields1943 = new BitSet(new ulong[]{0x4000000UL});
			public static readonly BitSet _type_field_in_type_fields1947 = new BitSet(new ulong[]{0x202UL});
			public static readonly BitSet _ID_in_type_field1964 = new BitSet(new ulong[]{0x100UL});
			public static readonly BitSet _COLON_in_type_field1966 = new BitSet(new ulong[]{0x4000000UL});
			public static readonly BitSet _ID_in_type_field1970 = new BitSet(new ulong[]{0x2UL});
		}
		#endregion Follow sets
	}
}